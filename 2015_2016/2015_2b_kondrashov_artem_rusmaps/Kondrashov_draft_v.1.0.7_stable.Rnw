\documentclass[10pt]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, russian]{babel}
\usepackage{amssymb,amsmath}
\usepackage{gensymb}
\usepackage{svg}
\usepackage{multicol}
\usepackage{color}
\usepackage{tablefootnote}
\usepackage{graphicx}
\usepackage[colorlinks, urlcolor=blue]{hyperref}
\textheight = 24cm
\textwidth = 16cm
\oddsidemargin=0pt
\topmargin = -1.5cm
\parindent = 24pt
\parskip = 0pt
\tolerance = 2000 
\flushbottom


%TeX command block
\newcommand*{\ico}[1]
          {%
              \raisebox{-.3\baselineskip}
                  {%
                    \includegraphics[
                        height=\baselineskip,
                        width=\baselineskip,
                        keepaspectratio,
                                    ]{#1}%
                  }%
          }

\begin{document}


	\begin{titlepage} 
		
		\thispagestyle{empty} 
		
		\begin{center} 
			
			\normalsize Национальный исследовательский университет <<Высшая школа экономики>>\\
			\vspace{6em}
			\Large КУРСОВАЯ РАБОТА\\
				  Визуализация экономических и статистических данных на картах с помощью R
				  
		\end{center}
		
		\vspace{12em}
		
			\hfill
			\vbox
				{
					\hbox{Выполнил: А.~А.~Кондрашов}
					\hbox{Факультет: МИЭФ}
					\hbox{Курс:~2}
					\hbox{Научный руководитель: Б.~Б.~Демешев}
				}		
				
		\vfill
		
		\begin{center}
		Москва\\2016
		\end{center}

			
	\end{titlepage} 

\tableofcontents


\newpage
\section{Введение}
Язык программирования R уже давно зарекомендовал себя в качестве инструмента (и даже среды\footnote{Сообщество The R Foundation предпочитает называть R средой, а не инструментом \url{https://www.r-project.org/about.html}.}) для работы с данными. На сегодняшний день, это один из самых используемых ЯП для этих целей: среди пользователей R есть как крупные компании\footnote{Более полный список можно найти по ссылке: \url{http://www.revolutionanalytics.com/companies-using-r}} (Bank of America, Facebook, Ford, Microsoft, Kickstarter и другие) и университеты, так и обычные люди, у которых есть необходимость провести исследование(я). Большим плюсом использования R в научной деятельности является его интеграция с \TeX, что позволяет создавать полноценные научные публикации (в том числе и эту курсовую работу) используя средства как R, так и \TeX, без необходимости работать в отдельных программах для верстки текста и написания программ. Также не стоит забывать, что R --- свободно распространяемое программное обеспечение, что делает его доступным такому широкому кругу лиц.

\vspace{6pt}
\noindent
Данная работа предназначена помочь начинающим и опытным исследователям в области экономики и статистики, использующим язык R для анализа данных. Возможности этого языка программирования в сфере обработки статистических и экономических данных можно назвать безграничными, поскольку спектр этих возможностей настолько широк, что вряд ли найдётся исследователь, которому понадобятся все эти возможности. Если же какие-то из необходимых инструментов отсутствуют или же, по мнению пользователя среды R, недостаточно тривиальны и нуждаются в упрощении, то он может создать собственные функции и даже пакет, предназначенный для решения какой-либо задачи, поскольку R - достаточно мощный язык программирования. 

\vspace{6pt}
\noindent
Среди ключевых возможностей R можно отметить проведение статистических тестов, работу с матрицами и массивами разной размерности, линейное и нелинейное моделирование, анализ временных рядов и, что немаловажно, построение графиков и диаграмм. Визуализация данных в R занимает особое место: этой теме посвящено множество работ, существует большое количество курсов и пакетов, расширяющих возможности R в этой сфере. В частности, R способен работать и с пространственными данными, а также визуализировать их посредством картограмм. Этой области возможностей R и посвящена данная работа: в ней я собираюсь рассмотреть различные способы получения геоданных (я буду называть их картами) и способы отображения привязанной к ним информации, составив подробные инструкции. В качестве дополнительного (но не менее самостоятельного) материала к этой работе прилагается разработанный мною пакет {\bf{rusmaps}}, содержащий карты России, на которых можно отображать различные данные. Подробнее с ним можно ознакомиться в секции 5.

\newpage
\section{Подготовка}
В данной секции я укажу необходимые элементы для работы, а также дам комментарии касательно их назначения.

\subsection{Среда R}
\vspace{6pt}
\noindent
В первую очередь, для работы нам понадобится среда R. Последнюю версию можно получить, пройдя по ссылке: \url{https://cran.r-project.org}. Далее, нам понадобится редактор кода R, и лучше всего для этого подойдёт Rstudio (\url{https://www.rstudio.com}), прежде всего благодаря своему удобству и интуитивной понятности интерфейса.

\vspace{6pt}
\noindent
Код лучше писать в окне скриптов (source pane), так как это позволит его сохранить. Также напомню важное правило при работе с любым файлом на компьютере: сохраняйте файл спустя определённые интервалы времени. Это обезопасит часы труда в случае экстренного завершения программы.

\vspace{6pt}
\noindent
В работе нам понадобятся следующие пакеты (некоторые пакеты будут подключены позже):

<<setup, message = FALSE, warning = FALSE>>=
#пакеты для создания карт:
library("ggplot2")
library("ggmap")
library("maptools")
library("tmap")
library("gridExtra")
#пакеты для создания интерактивных карт
library("leaflet")
library("plotly")
#пакеты для обработки данных
library("rgdal")  
library("rgeos")
library("dplyr")
library("tidyr")
#пакет для вывода графиков и карт, содержищих кириллицу, в pdf
library("Cairo")
#пакет, увеличивающий разнообразие цветовых палитр
library("RColorBrewer")
@

\noindent
Если какой-либо из пакетов отсутствует, то его необходимо загрузить с помощью команды {\texttt{install.packages("имя пакета")}}, либо же, пройдя по вкладке:

\vspace{6pt}
{\it{Tools -> Install packages\dots}}

\begin{figure}[bh]
  \begin{multicols}{2}
    \hfill
    \includegraphics[width=80mm]{picture002.png}
    \hfill
    \hfill
    \includegraphics[width=80mm]{picture001.png}
    \hfill
  \end{multicols}
\end{figure}

\noindent
выбрать и установить пакеты самостоятельно.

\subsection{GIS}
Для создания собственных shape-файлов, а также конвертации файлов геоданных разных форматов нам также понадобится QGIS (\url{http://www.qgis.org/ru/site/forusers/download.html}) или любая другая геоинформационная система. В данной работе, я буду использовать QGIS. Разумеется, перед тем, как начинать с ним работать, нужно его настроить под свои нужды.

\vspace{6pt}
\noindent
Нам понадобятся два модуля (плагина), которые можно загрузить, зайдя по вкладкам меню:

\vspace{6pt}
{\it{Модули -> Управление модулями\dots}}

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 140mm]{picture01.png}
  \end{center}
\end{figure}

\noindent
В открывшемся окне переходим на вкладку {\bf{<<Параметры>>}} и ставим флажок у {\bf{<<Разрешить установку экспериментальных модулей>>}}, так как один из необходимых модулей входит в категорию экспериментальных.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 140mm]{picture02.png}
  \end{center}
\end{figure}

\noindent
Наконец, перейдя на вкладку {\bf{<<Все>>}}, выбираем необходимые модули: {\bf{OSM Place Search}} (экспериментальный) и {\bf{OpenLayers}}, введя первые несколько букв названия в поле поиска, и загружаем их. Первый нужен для того, чтобы находить интересующие нас районы (места) в системе OSM, в то время как второй загружает слои (что очевидно из названий плагинов).

\begin{figure}[bh]
  \begin{multicols}{2}
    \hfill
    \includegraphics[width=80mm]{picture03.png}
    \hfill
    \hfill
    \includegraphics[width=80mm]{picture04.png}
    \hfill
  \end{multicols}
\end{figure}

\newpage
\noindent
Модуль {\bf{OpenLayers}} можно найти в меню {\bf{<<Интернет>>}}, 

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 100mm]{picture05.png}
  \end{center}
\end{figure}

\noindent
а {\bf{OSM Place Search}} появится как панель. В случае, если Вы случайно её закроете, её (как и остальные панели) можно вернуть по вкладкам меню:

\vspace{6pt}
{\it{Вид -> Панели -> OSM Place Search\dots}}

\vspace{6pt}
\noindent
На этом настройка QGIS завершена.

\subsection{Дополнительные настройки}
Поскольку данная работа включает в себя построение интерактивных карт, я решил добавить инструкцию для вывода карт, созданных с помощью {\bf{leaflet}} в формат pdf. Если это Вам не нужно, можете смело пропустить эту подсекцию.

\vspace{6pt}
\noindent
Для создания интерактивных карт с {\bf{leaflet}}\footnote{Подробнее на \url{https://cran.r-project.org/web/packages/leaflet/leaflet.pdf}}, нам понадобится одноимённый пакет (его мы загрузили и установили в подсекции <<Среда R>>). Чтобы сохранить полученную карту в pdf (также можно выбрать png и jpeg), нам понадобится пакет {\bf{webshot}}. Данный пакет требует ссылки на страницу, на которой нужно сделать скриншот, поэтому нам необходимо подключить пакет {\bf{htmlWidgets}}, чтобы создать документ html, содержащий параметры объекта leaflet. На этот файл и будет ссылаться команда {\texttt{webshot()}}.

<<setup2, message = FALSE, warnong = FALSE>>=
#пакеты для web-скриншотов (для работы требуется PhantomJS)
library("webshot")
library("htmlwidgets")
@

\noindent
Для работы пакета {\bf{webshot}}\footnote{Подробнее на \url{https://cran.r-project.org/web/packages/webshot/webshot.pdf}} нам понадобится {\bf{PhantomJS}} - консольный WebKit с интерфейсом {\bf{javascript}}. Скачать его можно с официального сайта: \url{http://phantomjs.org/download.html}, а пользователи Windows могут воспользоваться встроенной в пакет {\bf{webshot}} функцией {\texttt{install\_phantomjs(version = "2.1.1")}}, которая установит PhantomJS версии 2.1.1 (самая свежая на момент написания данной работы). Если же Вы пользуетесь другой ОС, то придётся выполнить сборку (по-английски build). Инструкцию можно найти по ссылке \url{http://phantomjs.org/build.html}. Я же расскажу как установить PhantomJS для OSX (El Capitan на момент написания).

\vspace{6pt}
\noindent
В первую очередь, необходимо скачать PhantomJS для OSX (ссылка выше). Распакуем полученный архив и в папке {\bf{bin}} найдём искомый файл. Теперь нам нужно поместить его в системную папку, путь к которой {\it{/usr/local/bin}}. Так как эти папки системные, то они скрыты, и чтобы их проявить, нужно воспользоваться Терминалом. Но я предлагаю другой, более простой метод:

\begin{enumerate}
  \item Перейдём на директорию жесткого диска (или SSD диска, в зависимости от конфигурации). Доступ к нему можно подключить через         настройки Finder.
  \item Введём комбинацию клавиш cmd+shift+G. Откроется окно перехода к другой папке, находящейся в данной директории, поиск <<видит>> скрытые папки (очень полезно когда в каталоге слишком много объектов). Введём <<usr>>.
        
        \begin{figure}[t]
          \begin{center}
            \includegraphics[width = 120mm]{picture006.png}
          \end{center}
        \end{figure}
  \item Далее проследуем по следующему пути:
          
          \vspace{6pt}
          {\it{usr/local/bin}}

              \begin{figure}[bh]
                \begin{center}
                  \includegraphics[width = 120mm]{picture005.png}
                \end{center}
              \end{figure}

  \item Здесь и должен находиться файл phantomjs. Копируем (или переносим) его в эту папку (потребуется подтверждение паролем администратора). Готово!

\end{enumerate}

\noindent
Теперь можно экспортировать скриншоты leaflet-карт в pdf.

\newpage
\section{Получение карты}

Для визуализации пространственных данных необходима картограмма, которую можно построить с помощью shape-файлов.
Shapefile\footnote{С техническим описанием можно ознакомиться на \url{https://www.esri.com/library/whitepapers/pdfs/shapefile.pdf}.} --- векторный формат для хранения объектов, содержащих географические данные, которые представлены в виде точек, линий или полигонов, а также соответствующие каждому объекту атрибуты (название, температура, площадь и т.д.).
Каждый файл хранит объекты только одного типа, то есть в одном файле не могут храниться точки и линии одновременно. Необходимо отметить, что для работы с объектом(ами) необходимы по крайней мере три файла (.shp, .shx, .dbf), поскольку они содержат разные данные об объекте. Основным файлом является .shp --- в нем хранится информация о геометрических объектах, далее следуют .dbf (файл базы данных --- атрибутов) и .shx --- индексный файл. Таким образом, shape-файл является готовым шаблоном для картограммы с привязанной таблицей с данными для анализа по регионам (точкам).

\vspace{6pt}
\noindent
В данной работе мы рассмотрим два способа получения shape-файла: использование различных интернет-ресурсов и создание собственного shape-файла в QGIS.

\subsection{Построение карты с помощью готового шаблона}
\noindent
В Интернете можно найти большое количество уже готовых shape-файлов, предназначенных для исследований разного рода. Как правило, нас будут интересовать файлы, содержащие полигоны, то есть описывающие территории (регионы) и как по ним распределены те или иные объекты изучения. 

\vspace{6pt}
\noindent
В качестве ресурсов, на которых можно найти готовые shape-файлы (а также файлы геоданных в других форматах, например, GeoJSON, речь о котором пойдет в другой подсекции), а также помощь для их редактирования, можно привести следующие сайты:

	\begin{itemize}
		
		\item GISLAB
			
			На данном сайте в разделе <<Геоданные>> можно найти несколько разделов, содержащих карты OpenStreetMap в формате shape-файлов. Есть уже готовые данные и несколько слоев. 
			
			Ссылка: \url{http://gis-lab.info/qa/data.html}
			
		\item GISGeo
		
			Очень полезный ресурс поскольку содержит не только ссылки на шаблоны карт, но и на данные, которые можно к ним привязать.
			
			Ссылка: \url{http://gisgeo.org/index.php?id=7#GovOpen}
			
		\item OpenStreetMap wiki 
			
			Собственно, центр знаний по проекту OSM. На странице <<Shapefiles>> можно найти ряд полезных ссылок.
			
			Ссылка: \url{https://wiki.openstreetmap.org/wiki/Main_Page}
			
		\item Highmaps
		
		  Доступно множество карт по разным странам и материкам, в форматах SVG, GeoJSON и Javascript.
		  
		  Ссылка: \url{http://code.highcharts.com/mapdata/}
		  
		\item Global Administrative Areas (GADM)
		
		  На данном источнике можно найти shape-файлы по разным странам (для некоммерческого использования, разрешены научные              публикации).
		  
		  Ссылка: \url{http://gadm.org}
		  
		  
		
	\end{itemize}

\noindent	
Стоит отметить, что использование готовых shape-файлов имеет свои недостатки, среди которых можно выделить:
	\begin{enumerate}
	
		\item Зависимость от обновлений.
		
		\item Отсутствие части данных (например, невозможность выделить регион по административному уровню, поскольку его нет в               таблице).
		
	\end{enumerate}


\subsubsection{Пример получения карты с GISLab}

\noindent
В данной секции я разберу пример получения карты с GISLab. Файлы в формате .shp можно найти по ссылке: \url{http://beryllium.gis-lab.info/project/osmshp/}.
Выбираем необходимый регион и жмем <<Скачать>>. В качестве примера я выбрал Хабаровск (\url{http://beryllium.gis-lab.info/project/osmshp/region/RU-KHA}). 

\vspace{6pt}
\noindent
Для начала установим рабочую директорию с помощью команды {\texttt{setwd()}}, либо по вкладкам меню: 

\vspace{6pt}
{\it{Session -> Set Working Directory -> Choose Directory...}}

\vspace{6pt}
\noindent
Будет проще, если рабочая директория не будет находиться в папке со слоями shape-файла (в данном случае это папка {\bf{data}}).

\vspace{6pt}
\noindent
Далее мы прочитаем содержимое shape-файла, параллельно занеся его содержимое в объект (назовем его {\bf{khab1}}). Для этого используем команду {\texttt{readOGR(dsn, layer)}}, где {\texttt{dsn}} - путь к директории, в которой находится shape-файл, а {\texttt{layer}} - имя слоя, который нас интересует. Нам нужен слой {\bf{boundary-polygon}}: он содержит информацию об административных границах регионов.

		
<<readogr, message = FALSE, warning = FALSE>>=
khab1 <- readOGR(dsn = "Карты/RU-KHA/data", "boundary-polygon")
@

\noindent
Полученный объект {\bf{khab1}} содержит информацию о 24 полигонах, являющимися границами регионов разного административного уровня\footnote{С полным списком административных уровней можно ознакомиться в Приложении 1}, и относится к классу {\bf{SpatialPolygonsDataFrame}} что наделяет его несколько иными от {\bf{dataframe}} свойствами. Команды, работающие с {\bf{dataframe}} применимы и к нему, однако требуют небольшой коррекции. В связи с тем, что объект Spatial класса состоит из слотов (ячеек), то нужно не только указать его имя, но и имя слота. То есть, чтобы получить доступ к данным атрибутов shape-файла, нужно указать слот {\texttt{@data}}. Чтобы получить первые 6 значений атрибутов, введём следующую команду:

<<head, message = FALSE, warning = FALSE>>=
head(khab1@data) #По умолчанию head() выводит 6 значений
@

\noindent
Также мы можем узнать, границы объектов какого административного уровня хранятся в файле. Для этого воспользуемся функцией {\texttt{unique()}}, которая выводит уникальные значения из вектора значений (в нашем случае, это будет столбец ADMIN\_LVL).

<<unique, message = FALSE, warning = FALSE>>=
unique(khab1@data$ADMIN_LVL)
@

\noindent
Как мы видим, в файле содержатся границы муниципальных районов и административные районы городских округов, которые нам и нужны.

\vspace{6pt}
\noindent
Допустим, у меня есть некоторые данные по административным округам Хабаровска. Отобразим карту командой {\texttt{plot(khab1)}, добавив {\texttt{main = }} для заголовка:


<<plot01, message = FALSE, warning = FALSE, echo = -c(1, 5), results = "hide">>=
cairo_pdf("plot01.pdf", pointsize = 15)
#Зададим размеры полей
par(mar = c(0, 0, 1, 0))
plot(khab1, main = "Хабаровский край")
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{plot01.pdf}
  \end{center}
\end{figure}

\noindent
Очевидно, что данная проекция содержит лишние полигоны, представляя карту в неудобном масштабе, а также увеличивает время прорисовки.
Чтобы отобразить только нужные регионы, необходимо выбрать их, указав их административный уровень, предварительно избавившись от значений {\texttt{<NA>}}, чтобы избежать ошибки.

<<NA_clear, message = FALSE, warning = FALSE>>=
khab1@data <- na.omit(khab1@data)
@

\noindent 
Функция {\texttt{na.omit}} принимает слот {\texttt{@data}} из объекта {\bf{khab1}}, и удаляет\footnote{Функция {\texttt{na.omit()}} может удалить строки с необходимыми полигонами, которые по ошибке есть недостающие значения. В таком случае лучше присвоить этим значениям имя или номер c помощью функции {\texttt{is.na()}}.} 
из него все строки, содержащие отсутствующие данные.

\vspace{6pt}
\noindent
Теперь нужно выбрать строки, содержащие данные по регионам нужного административного уровня.
Для административных округов города нам нужен девятый (9) уровень. Создадим новый объект {\bf{khab2}}, в который попадут только нужные нам полигоны и прорисуем его:

<<plot02, message = FALSE, warning = FALSE, echo = -c(2, 5), results = "hide">>=
khab2 <- khab1[khab1$ADMIN_LVL == 9, ]
cairo_pdf("plot02.pdf", pointsize = 15)
par(mar = c(0, 0, 1, 0))
plot(khab2, main = "Хабаровск")
dev.off()
@

\newpage
\begin{figure}[t]
  \begin{center}
    \includegraphics[width=90mm]{plot02.pdf}
  \end{center}
\end{figure}

\noindent
Таким образом, мы получили карту административных округов Хабаровска.

\vspace{6pt}
\noindent
В полученном объекте содержится всего 5 полигонов.
Переименуем ID каждого из них и выведем содержимое слота следующими командами:

<<ID rename, message = FALSE, warning = FALSE>>=
khab2$OSM_ID <- c(1, 2, 3, 4, 5) 
khab2@data
@

\noindent
Теперь к каждому региону можно обратиться по его номеру, но карта все ещё не информативна: невозможно определить, где какой район.
Закрасим Индустриальный район (под номером 2) красным цветом:

<<plot0304, message = FALSE, warning = FALSE, echo = -c(1, 5, 6, 10), results = "hide">>=
cairo_pdf("plot03.pdf", pointsize = 20)
par(mar = c(0, 0, 1, 0))
plot(khab2, main = "Правильная карта")
plot(khab2[khab2$OSM_ID == 2, ], col = "red", add = TRUE) #Получим карту слева
dev.off()
cairo_pdf("plot04.pdf", pointsize = 20)
par(mar = c(0, 0, 1, 0))
plot(khab2, main = "Правильная карта")
plot(khab2[khab2$OSM_ID == 2, ], col = "red", 
     add = FALSE, main = "Неправильная карта") #Получим карту справа
dev.off()
@

\newpage
\begin{figure}[t]
  \begin{multicols}{2}
    \hfill
    \includegraphics[width=65mm]{plot03.pdf}
    \hfill
    \hfill
    \includegraphics[width=65mm]{plot04.pdf}
    \hfill
  \end{multicols}
\end{figure}


\noindent
Заметим, что параметр {\texttt{add = TRUE}} нужен для того, чтобы последующее изображение наслоилось на предыдущее (также нам потребуется 2 команды {\texttt{plot()}}). В противном случае мы получим изображение отдельного района, как на рисунке справа.

\vspace{6pt}
\noindent
Наконец, сделаем легенду для нашей карты. Функция {\texttt{plot()}} в данном случае потребует громоздкой конструкции (для компактности используем цикл for и создадим вектора цветов и имен районов):

<<plot05_1, message = FALSE, warning = FALSE, echo = -c(1, 7), results = "hide">>=
cairo_pdf("plot05_1.pdf", pointsize = 12)
leg <- as.vector(khab2@data$NAME)
col.vec <- c("red", "green", "blue", "magenta", "orange")
plot(khab2, main = "Хабаровск")
for (i in 1:length(khab1@data$OSM_ID))
  { #С помощью цикла мы закрасим 5 областей
    plot(khab2[khab2$OSM_ID == i, ], col = col.vec[i], add = TRUE)
  }
legend("bottomleft", leg, bg = "transparent", box.lty = 0,
       fill = col.vec, title = "Районы", cex = 0.9, title.adj = 0.22)
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 85mm]{plot05_1.pdf}
  \end{center}
\end{figure}

\noindent
поэтому разумнее воспользоваться пакетом {\texttt{ggplot2}}. Карта, а также все визуальные усовершенствования (к примеру, легенда и подписи осей координат) будут храниться в отдельном объекте, который мы назовём {\bf{khab.map}}. Команды выглядят следующим образом (замечу, что система координат\footnote{Система координат задается кодом EPSG, подробнее на \url{https://goo.gl/DcEVwT}} для всех прилагающихся shape-файлов --- WGS 84 (код: EPSG 4326) и не нуждается в коррекции):

<<plot05, message = FALSE, warning = FALSE, echo = -c(1, 10), results = "hide">>=
cairo_pdf("plot05.pdf", pointsize = 25, width = 12, height = 8)
#Перевод проекции карты в dataframe:
map.df <- fortify(khab2, region = "NAME")
#Создание окружения для карты:
plot5theme <- theme(axis.text = element_text(size = 12),
                    axis.title = element_text(size = 18),
                    legend.text = element_text(size = 18),
                    legend.title = element_text(size = 20),
                    plot.title = element_text(size = 23, face = "bold"))
#Создание объекта карты:
khab.map <- ggplot(map.df, aes(long, lat, group = group, fill = id)) +
            #Добавим alpha = 0.7, чтобы полигоны слегка просвечивали
            geom_polygon(color = "white", alpha = 0.7) +
            coord_map() +
            labs(x = "Долгота", y = "Широта", fill = "Название региона") +
            ggtitle("Хабаровск")
#Выведем полученный объект:
khab.map + plot5theme
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 125mm]{plot05.pdf}
  \end{center}
\end{figure}

\noindent
Теперь нам вполне понятно расположение регионов на карте\footnote{Несмотря на наглядность, эту карту разумнее назвать схемой (картограммой), так как ориентироваться по ней почти невозможно. Однако, этого может быть вполне достаточно для решения многих задач.}. С помощью ggplot2 стало возможном наслоение карты на систему координат в градусах, а также полупрозрачности и других эффектов.
Если же значения широты и долготы не нужны, то их можно удалить добавив к объекту {\bf{khab.map}} команды {\texttt{scale\_x\_discrete}} и {\texttt{scale\_y\_discrete}} для осей х и у соответственно. Касательно окружения (оформления) карты, как и любого другого графика, я рекомендую самостоятельно поэкспериментировать с элементами функции {\texttt{theme()}}. К примеру, если я хочу получить карту без легенды и значений широты и долготы, то моя команда будет выглядеть следующим образом:

<<plot06, message = FALSE, warning = FALSE, echo = -c(1, 7), results = "hide">>=
cairo_pdf("plot06.pdf", pointsize = 25, width = 12, height = 8)
#Удалим fill = id, чтобы убрать легенду
#Также удалим labs, поскольку подписи осей теперь тоже не нужны
khab.map.noax <- ggplot(map.df, aes(long, lat, group = group)) +
            geom_polygon(color = "white") +
            coord_map() +
            ggtitle("Хабаровск") +
            scale_x_discrete(breaks = NULL) +
            scale_y_discrete(breaks = NULL)
#Отобразим карту
khab.map.noax + plot5theme + theme(axis.title = element_blank())
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 105mm]{plot06.pdf}
  \end{center}
\end{figure}

\noindent
Таким образом, мы рассмотрели пример получения карты Хабаровска, используя готовый шаблон с GISLAB.

\subsubsection{Построение карты в формате geoJSON}
GeoJSON\footnote{С более подробной спецификацией можно ознакомиться на \url{http://gis-lab.info/docs/geojson_ru.html}}, как и shapefile, является популярным форматом для хранения геоданных, обладающим своими преимуществами и недостатками. К его преимуществам можно отнести то, что, во-первых, geoJSON существует в виде одного документа, в то время как shapefile для работы требует три. Во-вторых, данные в geoJSON хранятся в виде программного кода (javascript), который понятен человеку и который можно редактировать средствами, отличными от GIS. Это делает его даже более популярным среди программистов, особенно среди тех, кто работает с интерактивными картами и пространственными данными в целом. К недостаткам же можно отнести меньшую, в отличие от shape-файлов компактность: размер файлов geoJSON, как правило, в два раза больше shapefile (и, возможно, требует упрощения геометрии границ\footnote{Подробнее в секции 3.2.4}). 

\vspace{6pt}
\noindent
В Интернете распространены ресурсы, на которых можно найти данные в формате geoJSON. В качестве примера я могу привести {\bf{Портал открытых данных Правительства Москвы}} (\url{http://data.mos.ru}). На нём можно найти различные данные об инфраструктуре Москвы в виде точек, линий и полигонов. GeoJSON можно получить с помощью API, а файлы в формате .json и .docx доступны без регистрации. Как вариант, мы можем взять файл .json и переделать его в .geojson, так как это практически один и тот же формат, а их различие лишь в синтаксисе и в типе содержащихся данных (то есть, в .json хранятся просто данные (как таблица) о, допустим, названии, посещаемости и координатах, в то время как .geojson содержит в себе информацию о точках (как объектах), с теми же параметрами, но код файла делает его пригодным для обработки в GIS). Таким образом, всё что нам нужно сделать, это создать файл, в котором мы опишем объекты, как это делается для geoJSON. Для этого нам понадобится любой рекадтор программного кода (например, notepad++ и его аналоги. Можно использовать и Rstudio, но подсветки синтаксиса не будет). Также будет полезно сделать шаблон файла geojson для каждого типа данных (точек, линий и полигонов). 

\vspace{6pt}
\noindent
Приведу пример создания точечного geojson из данных о московских кофейнях (данные можно найти здесь: \url{http://data.mos.ru/opendata/7710881420-kofeyni}). Для начала нам нужно получить шаблон geojson, содержащего точки. Для этого можно сохранить любой набор точек, созданный в QGIS (для примера возьму города-миллионеры). Откроем полученный файл редактором кода, и обнаружим, что geojson выглядит следующим образом (приведена часть файла):

  \begin{verbatim}
  
"type": "FeatureCollection",
"crs": {
  "type": "name",
  "properties": {
    "name": "urn:ogc:def:crs:OGC:1.3:CRS84"
      }
    },
    "features": [
  {
    "type": "Feature",
    "properties": {
      "id": "21053210",
      "name": "Воронеж",
      "pop_2015": 1023570
    },
    "geometry": {
      "type": "Point",
      "coordinates": [
              39.1607149,
              51.6587727
            ]
        }
    }
}
  \end{verbatim}
  
\noindent
Данный файл можно поделить на две составные части: <<шапку>>, где указан тип содержимого файла и система координат (1--8 строки) и перечисления объектов и их свойств (properties и geometry).

\vspace{6pt}
\noindent
Что касается файла .json, то он состоит из объектов, описанных следующим образом:

  \begin{verbatim}
[
  {
    "Lat": 55.78994653781263,
    "Lon": 37.63429892286436,
    "Id": "d9629d7f-9a30-43a7-835b-dad95ea3c7ad",
    "Number": 1,
    "Cells": {
      "global_id": 20660592,
      "Name": "Кофеня «Кофе Хаус»",
      "IsNetObject": "да",
      "OperatingCompany": "Кофе Хаус",
      "AdmArea": "Центральный административный округ",
      "District": "Мещанский район",
      "Address": "проспект Мира, дом 77, корпус 1",
      "PublicPhone": "(495) 221-83-81"
      "SeatsCount": 15,
      "SocialPrivileges": "нет",
      "Longitude_WGS84": "37.6342989228643600",
      "Latitude_WGS84": "55.7899465378126320"
    }
  }
]
  \end{verbatim}
  
\noindent
Очевидно, что для получения geojson с данными о кофейнях нужно просто верно написать <<шапку>> с системой координат и типом содержимого, и ввести соответствующие properties (в json они находятся в cells) и координаты. Аналогичным путём можно создать и свой собственный geojson. Для большого количества точек процесс достаточно однообразный, поэтому я вписал первые 10 объектов. Чтобы быстро преобразовывать большое количество данных, можно воспользоваться скриптом (например на Python), который выполнит замену автоматически.

  \begin{verbatim}
  {
    "type": "FeatureCollection",
    "crs": { 
      "type": "name", 
      "properties": { 
          "name": "urn:ogc:def:crs:OGC:1.3:CRS84" 
        } 
    },
      "features": [
        {
          "type": "Feature",
          "properties": {
              "global_id": 20660592,
              "Name": "Кофеня «Кофе Хаус»",
              "IsNetObject": "да",
              "OperatingCompany": "Кофе Хаус",
              "AdmArea": "Центральный административный округ",
              "District": "Мещанский район",
              "Address": "проспект Мира, дом 77, корпус 1",
              "PublicPhone": "(495) 221-83-81",						
              "SeatsCount": 15,
              "SocialPrivileges": "нет"
              },
          "geometry": {
              "type": "Point",
              "coordinates": [
                  37.63429892286436,
                  55.78994653781263
              ]
          }
      }
  \end{verbatim}

\vspace{6pt}
\noindent
Отобразим местоположения кофеен. В качестве фона можно воспользоваться картой административных округов Москвы (в формате geojson), которую можно получить по сслыке: \url{http://gis-lab.info/qa/moscow-atd.html}.

<<data_create, message = FALSE, warning = FALSE>>=
mosmap <- readOGR("Карты/geojson/Москва.geojson", "OGRGeoJSON")
coffee <- readOGR("Карты/geojson/Кофейни.geojson", "OGRGeoJSON")
@

<<coffee, message = FALSE, warning = FALSE, echo = -c(1, 5), results = "hide">>=
cairo_pdf("coffee.pdf", pointsize = 12)
par(mar = c(0, 0, 1, 0))
plot(mosmap, main = "Кофейни в Москве")
plot(coffee, add = TRUE, col = "brown", pch = 20)
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 90mm]{coffee.pdf}
  \end{center}
\end{figure}

\noindent
В качестве альтернативы можно воспользоваться API портала. Для этого мы можем воспользоваться пакетом {\bf{datamos}} (репозиторий: \url{https://github.com/bdemeshev/datamos}), который можно установить с помощью команды:

<<install_datamos, message = FALSE, warning = FALSE>>=
devtools::install_github("bdemeshev/datamos")
library(datamos)
@

\noindent
Теперь с помощью функции {\texttt{datamos()}}, введя ID данных в качестве аргумента. ID можно узнать, кликнув по вкладке <<Паспорт>> как на скриншоте:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{picture45.png}
  \end{center}
\end{figure}

\newpage
\noindent
Теперь с помощью команды {\texttt{names()}} мы можем узнать названия столбцов и выбрать те, которые нам нужны. Функция {\texttt{datamos()}} возвращает набор данных, который нужно конвертировать в SpatialPointsDataFrame. Это можно сделать с помощью функции {\texttt{coordinates()}}. 

<<datamos_get, message = FALSE, warning = FALSE>>=
coffee1 <- datamos(1786)
names(coffee1)
coffee1 <- coffee1[, c(1, 2, 6, 7, 8, 10, 13)]
coordinates(coffee1) <- ~Lon+Lat
@

<<coffee1.plot, message = FALSE, warning = FALSE, echo = -c(1, 5), results = "hide">>=
cairo_pdf("plot_coffee1.pdf", pointsize = 12)
par(mar = c(0, 0, 1, 0))
plot(mosmap, main = "Кофейни в Москве")
plot(coffee1, add = TRUE, col = "brown", pch = 20)
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 130mm]{plot_coffee1.pdf}
  \end{center}
\end{figure}

\subsubsection{Конвертация файлов геоданных}
В случаях, если Вам по какой-либо причине нужно изменить формат файла, содержащего необходимые Вам географические данные, то его необходимо конвертировать. Я приведу несколько способов как это сделать:

  \begin{itemize}
    \item Mapshaper
    
          Удобный и практичный вариант, если Вы планируете пользоваться исключительно shape-файлами и geoJSON и не хотите               пользоваться QGIS. Позволяет немного подредактировать карту (с помощью консоли) прямо в браузере и экспортировать 
          её в форматах shapefile, geoJSON, topoJSON а также CSV и SVG. Работает в Chrome, Firefox и Safari, но в последнем 
          не поддерживает экспорт. Opera и IE не поддерживаются.
          
          Ссылки: \url{http://mapshaper.org/}, \url{https://goo.gl/BFkjV7}
          
    \item gisconvert.com
    
          Тут можно конвертировать <<экзотику>>, вроде файлов AutoCAD (DXF), Google KML и другие. Также есть конвертор GPX              (используется на устройствах GPS, в том числе на мобильных телефонах). 
          
          Ссылка: \url{https://www.gisconvert.com}
          
    \item R
    
          Для ковертации можно пользоваться и средствами R. Для чтения файлов мы пользуемся {\texttt{readOGR()}} 
          (также можно использовать {\texttt{readShapePoly()}} и другими функциями из пакета {\bf{maptools}}). При этом           мы получаем объект SpatialPolygonsDataFrame. Для записи файлов в формате shapefile можно воспользоваться                функцией {\texttt{writePolyShape()}} (для полигонов), а для geojson --- функциями {\texttt{geojson\_json()}}            из пакета {\bf{geojsonio}} и {\texttt{geojson\_write()}}. Можно воспользоваться и {\texttt{writeOGR()}}, но             вышеприведённые способы проще и менее конфликтны в настройках.
          
          <<convert, message = FALSE, warning = FALSE, eval = FALSE>>=
          x <- readOGR("Карты/Города_миллионники", "Воронеж")
          #Конвертация в geojson
          library("V8")
          library("geojsonio")
          x1 <- geojson_json(x)
          #Сохранение как geojson
          geojson_write(x1, file = "Карты/geojson/FILE.geojson")
          #Сохранение как shapefile
          writePolyShape(x, "Карты/Слой")
          @
          
    \item QGIS
    
          При сохранении файла в QGIS доступен выбор из 23 форматов, включая все вышеперечисленные, за исключением SVG.                 Учитывая возможности этой программы, я рекомендую именно этот вариант.
  
  \end{itemize}



\newpage
\subsection{Работа в QGIS}
В качестве альтернативы использованию готовых shape-файлов можно создать свои собственные. Такой подход позволяет создать файлы с необходимыми для работы полигонами, без необходимости что-то из них убирать. Также можно использовать QGIS для получения данных, имеющихся в базе, представленных в виде точек и линий (к примеру, различные учреждения, дороги), поскольку использование полигонов для их визуализации нецелесообразно.

\subsubsection{Получение данных OSM}
В данной секции я разберу пример получения геоданных с помощью QGIS (версия 2.14.3-Essen на момент написания работы), используя данные OpenStreetMap. В качестве примера я снова возьму Хабаровск.

\vspace{6pt}
\noindent
Для начала, загрузим карту OSM (необходимо подключение к Интернету). Для этого, перейдем по вкладкам меню:

\vspace{6pt}
{\it{Интернет -> OpenLayers plugin -> OpenStreetMap -> OpenStreetMap}}

\vspace{6pt}
\noindent
В рабочей области появится карта мира. Введем в поле поиска на панели {\bf{OSM place search\dots}} имя искомого города и выберем наиболее подходящий вариант. Он будет подсвечен на карте, а также займёт всю рабочую область:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{picture07.png}
  \end{center}
\end{figure}

\noindent
Загрузим данные\footnote{В зависимости от города, размер загруженных данных варьируется и может быть весьма большим (100Мб и более для крупных городов).}, имеющиеся на карте. Стоит добавить, что данные загружаются с области, которая находится в рабочей области. То есть если приблизить карту с помощью инструмента {\it{Лупа}} то область загрузки данных уменьшится. Итак, пройдём по вкладкам меню (туда мы ещё не раз вернёмся):

\vspace{6pt}
{\it{Вектор -> OpenStreetMap -> Загрузить данные\dots}}

\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 140mm]{picture08.png}
  \end{center}
\end{figure}

\noindent
В открывшемся диалоговом окне нажав на кнопку с многоточием, выберем директорию, куда сохраним загруженные данные, а также название выходного файла. Получим файл в формате .osm (OSM XML\footnote{Подробнее по ссылке: \url{http://wiki.openstreetmap.org/wiki/OSM_XML}}).

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 60mm]{picture09.png}
  \end{center}
\end{figure}

\noindent
Для дальнейшей работы нам необходимо конвертировать этот файл в базу данных. Для этого, пройдем по вкладкам меню:

\vspace{6pt}
{\it{Вектор -> OpenStreetMap -> Импортировать топологию\dots}}

\vspace{6pt}
\noindent
В открывшемся диалоговом окне выберем полученный ранее .osm файл, установим флажок (он здесь один) и нажмём ОК.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 60mm]{picture10.png}
  \end{center}
\end{figure}

\noindent
Наконец, выведем слои геометрии SpatiaLite\footnote{SpatiaLite - расширение ядра SQLite (Система управления базами данных), позволяющее работать с геоданными.} пройдя по вкладкам меню:

\vspace{6pt}
{\it{Вектор -> OpenStreetMap -> Экспортировать топологию в SpatiaLite\dots}}

\vspace{6pt}
\noindent
В открывшемся диалоговом окне выберем созданный ранее файл базы данных (.db), кликнув по кнопке с многоточием. Здесь нам предстоит выбор, какие пространственные объекты нам нужны: точки, линии или полигоны. От себя скажу, что каких-то элементов в базе может недоставать (или могут отсутствовать значения в одной из ячеек строки). К примеру, если Вам нужно провести исследование по микрорайонам города, то выбрав <<полигоны>> Вы можете разочароваться в результате. С другой стороны, вариант с полигонами неплох для исследований землепользования. В остальных случаях имеет смысл взять точечные данные (местоположения заправочных станций, школ, больниц), хотя и они могут быть неполными. В любом случае, отмечаем выбор слева от необходимых объектов (в моём случае это будут точки). Щелкнув по кнопке <<Загрузить из БД>> получим список имеющихся тегов. Нас интересуют теги {\bf{name (название)}} и {\bf{amenity (удобства)}}.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 90mm]{picture11.png}
  \end{center}
\end{figure}

\noindent
Результат выглядит следующим образом:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{picture12.png}
  \end{center}
\end{figure}

\noindent
Обратим внимание на панель слоёв. В ней появился объект {\bf{Khab\_points}}, который содержит все точки, находящиеся в рабочей области. Разумеется, все они нам не нужны, и чтобы выбрать только нужные, необходимо создать запрос. Но сперва я рекомендую ознакомиться с содержащимися в слое элементами. Для этого щёлкнем правой клавишей мыши (ПКМ) по слою {\bf{Khab\_points}} и выберем опцию {\it{Открыть таблицу атрибутов}}.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 90mm]{picture13.png}
  \end{center}
\end{figure}

\noindent
На экране появится таблица, в нашем случае состоящая из трёх столбцов. Два из них - {\bf{name}} и {\bf{amenity}} - выбраны по тэгам, которые мы выбрали при экспорте топологии. То есть в зависимости от количества выбранных тэгов будет различаться число столбцов, и, как следствие, возможности в построении запроса. Щёлкнув по названию колонки, список в ней будет отсортирован по алфавиту, причём связь между ячейками в строках не нарушится. То есть щёлкнув по <<amenity>> мы получим список, отсортированный по параметру <<удобства>>. 

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{picture14.png}
  \end{center}
\end{figure}

\noindent
Теперь перейдём непосредственно к созданию запроса. Для этого закроем таблицу атрибутов, щёлкнем правой клавишей мыши по слою {\bf{Khab\_points}} и выберем опцию {\it{Фильтр\dots}}

\begin{figure}[t]
  \begin{center}
    \includegraphics[width = 90mm]{picture15.png}
  \end{center}
\end{figure}

\noindent
В появившемся окне в поле <<Выражение>> запишем команду для запроса: {\texttt{''amenity'' = 'bank'}}. Очень важно, чтобы название параметра ({\bf{amenity}}) было заключено в двойные кавычки, а значение параметра ({\bf{bank}}) - в апострофы. В качестве альтернативного способа ввода выражения запроса можно выбрать имя параметра из группы <<Поля>>, логические операции вводить имеющимися кнопками,а значения параметра выбрать из группы <<Значения>> (предварительно отобразив их, щёлкнув по кнопке <<Образец>>). Для данного примера я выбрал банки, поскольку их достаточно много, а также почти у всех объектов есть имя, что увеличивает ценность данных.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 90mm]{picture16.png}
  \end{center}
\end{figure}

\noindent
В результате количество точек на карте существенно уменьшится. Теперь на ней отображены только точки по запросу, то есть те, что обозначают местоположение банков в Хабаровске. 

\newpage
\begin{figure}[t]
  \begin{center}
    \includegraphics[width = 138mm]{picture17.png}
  \end{center}
\end{figure}

\noindent
Теперь нам нужно убедиться, что наши данные <<не содержат брака>>. Под словом <<брак>> я буду понимать опечатки. Для этого откроем таблицу атрибутов для точек, выбранных по запросу (по тому же {\bf{Khab\_points}}).

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 138mm]{picture21.png}
  \end{center}
\end{figure}

\noindent
Теперь, как мы это делали с {\bf{amenity}}, отсортируем список по названиям банков (красный кружок), и проверим, нет ли опечаток. Названия одинаковых банков должны быть одинаковыми и располагаться в списке вместе. Щёлкнув по иконке карандаша на панели инструментов, мы перейдём в режим редактирования. Исправим все опечатки. После этого, щёлкнем по иконке с дискетой, чтобы сохранить изменения.

\vspace{6pt}
\noindent
Нам остаётся лишь сохранить выбранные точки в shapefile (при желании, есть и другие форматы, в том числе и geoJSON). Для этого щёлкнем ПКМ по слою {\bf{Khab\_points}} и выберем опцию {\it{Сохранить как\dots}}

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 70mm]{picture19.png}
  \end{center}
\end{figure}

\noindent
Теперь испытаем наш собственноручно созданный shape-файл. В Rstudio мы построим карту Хабаровска и выполним наслоение координат банков:

<<6banks, message = FALSE, warning = FALSE>>=
khab.banks <- readOGR("Карты/Хабаровский_край", "banks")
head(khab.banks@data)
@

\noindent
Как видим, мы получили полноценный shape-файл. Теперь добавим точки, содержащиеся в файле на карту Хабаровска.

<<plot07, message = FALSE, warning = FALSE, echo = -c(1, 5), results = "hide">>=
cairo_pdf("plot07.pdf", pointsize = 20)
par(mar = c(0, 0, 1, 0))
plot(khab2, main = "Банки в г.Хабаровск")
plot(khab.banks, add = TRUE, pch = 0)
dev.off()
@

\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 70mm]{plot07.pdf}
  \end{center}
\end{figure}

\noindent
Таким образом, мы улучшили нашу карту Хабаровска, добавив на неё дополнительные геоданные. Но всё же полученный результат даёт представление лишь о том, в каких районах столько банков а также плотность их расположения. Поэтому, мы сделаем карту с помощью пакета {\bf{ggmap}}, который является расширением пакета {\bf{ggplot2}}.

\vspace{6pt}
\noindent
Для начала нам необходимо получить фон для карты. Для этого воспользуемся функцией {\texttt{get\_map()}}. Более того, функция {\texttt{ggmap()}} принимает только результат {\texttt{get\_map()}}. По умолчанию загружается GoogleMaps, но при желании, указав {\texttt{source = ''osm''}} можно вывести карту OSM. Для разнообразия, сделаем на базе карты Google:

<<getmap, message = FALSE, warning = FALSE>>=
#В get_map работает поиск по городу.
mapsource <- get_map(location = "Khabarovsk", zoom = 10)
@

\noindent
Теперь нам нужно сделать небольшие приготовления для построения объекта {\bf(ggmap)}. А именно перевести данные о координатах точек (банков) в {\bf{dataframe}}, поскольку {\bf{ggplot2}} не работает с объектами класса {\bf{SpatialPointsDataFrame}}. Функция {\texttt{fortify()}} здесь не подойдёт, но можно сохранить слот {\texttt{@coords}} как dataframe. Для этого введём команду: 

<<banks.coords, message = FALSE, warning = FALSE>>=
banks.coords <- as.data.frame(khab.banks@coords)
@

\noindent
Теперь перейдём непосредственно к построению:

<<plot08, message = FALSE, warning = FALSE, echo = -c(1, 4), results = "hide">>=
cairo_pdf("plot08.pdf", pointsize = 25, width = 12, height = 8)
khab.bank.map <- ggmap(mapsource) +
             #alpha = 0.7 НЕ должно быть в aes(), иначе получим ненужные элементы легенды
             geom_polygon(data = map.df, alpha = 0.7, color = "white",
                          aes(long, lat, group = group, fill = id)) +
             geom_point(data = banks.coords, size = 2, pch = 1,
                        aes(coords.x1, coords.x2)) +
             labs(x = "Долгота", y = "Широта", fill = "Название района") +
             ggtitle("Банки в г.Хабаровск")
khab.bank.map + plot5theme
dev.off()
@

\newpage
\begin{figure}[t]
  \begin{center}
    \includegraphics[width = 190mm]{plot08.pdf}
  \end{center}
\end{figure}

\noindent
В результате получаем весьма красивую (и информативную) карту. Теперь это действительно карта, а не схема. Но расположение точек на ней выглядит некрасиво. Чтобы это исправить, нужно создать объект {\bf{dataframe}}, который будет содержать в себе названия банков и их координаты. Для этого выполним следующие команды:

<<khab.banks.df, message = FALSE, warning = FALSE>>=
khab.banks.df <- as.data.frame(khab.banks@data)
khab.banks.df[, 4] <- banks.coords[, 1]
khab.banks.df[, 5] <- banks.coords[, 2]
names(khab.banks.df)[4] <- "coords.x"
names(khab.banks.df)[5] <- "coords.y"
head(khab.banks.df)
@

\noindent
Как мы видим, в объекте {\bf{khab.banks.df}} хранятся координаты и названия банков. Теперь мы можем построить карту (для удобства, полигоны будут удалены). На этот раз, сделаем её в OSM:

<<plot09, message = FALSE, warning = FALSE, echo = -c(1, 5), results = "hide">>=
cairo_pdf("plot09.pdf", pointsize = 25, width = 12, height = 8)
mapsource <- get_map(location = "Khabarovsk", zoom = 11, source = "osm")
khab.banks.points <- ggmap(mapsource) +
                     geom_point(data = khab.banks.df, 
                                aes(coords.x, coords.y, color = name), 
                                size = 3, alpha = 0.7) +
                     labs(x = "Долгота", y = "Широта", 
                          color = "Название банка") +
                     #rainbow(x) задаёт палитру цветов. Разных банков у нас 15.
                     scale_color_manual(values = rainbow(15)) +
                     ggtitle("Банки в г.Хабаровск")
khab.banks.points + plot5theme
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 190mm]{plot09.pdf}
  \end{center}
\end{figure}

\noindent
Теперь мы имеем представление о том, как визуализировать точечные данные, а также познакомились с пакетом {\bf{ggmap}}. Предлагаю сделать карту дорог Хабаровска. Процедура получения shape-файла в данном случае аналогична, только вместо точек нужно выбрать {\bf{полилинии}} в соответствующем окне. Загружать данные и конвертировать их в базу данных уже не нужно, если Вы её не удалили. Из тэгов возьмите {\bf{highway}} и {\bf{name}}. Далее нужно продублировать слой {\bf{Khab\_polylines}} дважды и сделать к каждому из полученных слоёв {\bf{отдельный}} запрос ({\texttt{''highway'' = 'primary', ''highway'' = 'secondary'}} и {\texttt{''highway'' = 'tertiary'}} соответственно) и сохранить как отдельные объекты, чтобы было проще их строить (пусть и в ущерб длине кода). В качестве объектов построения я выбрал три категории дорог по их значимости\footnote{Подробнее на \url{http://wiki.openstreetmap.org/wiki/RU:Key:highway}}. 

\vspace{6pt}
\noindent
Для начала, загрузим shape-файлы и сконвертируем их в dataframe:

<<load_roads, message = FALSE, warning = FALSE>>=
khab.roads1 <- readOGR("Карты/Хабаровский_край", "primary_roads")
khab.roads2 <- readOGR("Карты/Хабаровский_край", "secondary_roads")
khab.roads3 <- readOGR("Карты/Хабаровский_край", "tertiary_roads")
#конвертация
roads1.df <- fortify(khab.roads1)
roads2.df <- fortify(khab.roads2)
roads3.df <- fortify(khab.roads3)
@

\vspace{6pt}
\noindent
Поскольку схематичная карта (построенная командой {\texttt{ggplot()}}) в данном случае не совсем удобна, я предлагаю вновь использовать {\texttt{ggmap}}. 

<<plot10, message = FALSE, warning = FALSE, echo = -c(1, 5), results = "hide">>=
cairo_pdf("plot10.pdf", pointsize = 25, width = 12, height = 8)
mapsource <- get_map(location = "Khabarovsk", zoom = 11)
khab.roads.map <- ggmap(mapsource) +
                  geom_line(data = roads1.df, 
                            aes(long, lat, group = group, color = "primary"), 
                            alpha = 0.8) +
                  geom_line(data = roads2.df, 
                            aes(long, lat, group = group, color = "secondary"), 
                            alpha = 0.8) +
                  geom_line(data = roads3.df, 
                            aes(long, lat, group = group, color = "tertiary"), 
                            alpha = 0.8) +
                  labs(x = "Долгота", y = "Широта") +
                  ggtitle("Основные дороги г.Хабаровск") +
                  scale_colour_manual(values = c("red", "blue", "green"), 
                                      labels = c("primary", "secondary", "tertiary"),
                                      name = "Дороги")
khab.roads.map + plot5theme
dev.off()
@

\newpage
\begin{figure}[t]
  \begin{center}
    \includegraphics[width = 190mm]{plot10.pdf}
  \end{center}
\end{figure}

\noindent
Таким образом, мы научились получать и строить объекты любого типа, используя как обычные графические средства R ({\texttt{plot()}}), так и более продвинутые ({\texttt{ggplot2}} и {\texttt{ggmap}}).

\subsubsection{Рисование векторных слоёв}
\noindent
Бывают случаи, когда нужного shape-файла (или другого готового материала) попросту не существует. К примеру, речь идёт об исследовании труднодоступного и малоисследованного участка, или же есть необходимость разделить какой-либо регион на сектора по особым правилам.  В таких случаях нужно нарисовать необходимые полигоны, точки или линии самостоятельно, в зависимости от требуемых данных.

\vspace{6pt}
\noindent
В этом разделе я разберу пример создания shape-файла, содержащего полигоны. Последовательность действий для точечных и линейных данных аналогична, за некоторыми исключениями\footnote{Полная инструкция для всех видов данных доступна по ссылке: \url{http://gis-lab.info/qa/qgis-vector.html}}. В качестве абстрактного примера я придумал следующий сценарий: допустим, я хочу сопоставить численность популяций некоего вида животных в разных секторах Большехехцирского заповедника (расположен к югу от Хабаровска) и сравнить её с популяциями в секторах вне заповедника (сравнение данных, относящихся к разным группам регионов, мы разберём подробнее в секции визуализации экономических данных). 

\vspace{6pt}
\noindent
Приступим. Откроем QGIS и загрузим слой OSM ({\it{Интернет -> OpenLayers plugin -> OpenStreetMap -> OpenStreetMap}}). Затем, создадим новый векторный слой. Для этого перейдём по вкладкам меню:

\vspace{6pt}
{\it{Слой -> Создать слой -> Создать shape-файл\dots}}

\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 140mm]{picture22.png}
  \end{center}
\end{figure}

\vspace{6pt}
\noindent
Откроется диалоговое окно:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 60mm]{picture23.png}
  \end{center}
\end{figure}

\noindent
Здесь нам необходимо выбрать тип данных (в нашем случае это будут полигоны). Далее, чтобы создать файл, нужно добавить хотя бы одно поле (поле id, как правило, ставится по умолчанию), иначе создаваемые объекты (например, полигоны), будет невозможно идентифицировать по какому-либо признаку. Я добавил поля name (имя), type (тип) и data (данные, то есть численность популяции). При желании, поле с данными можно создать в R и задать им формулу генерации (или добавить из другой таблицы). Поля лучше продумать заранее. Определившись, щёлкаем по кнопке ОК. Новый слой отобразится на панели слоёв.

\vspace{6pt}
\noindent
При необходимости, можно настроить параметры построения (оцифровки). Для этого, перейдём по вкладкам меню: 

\vspace{6pt}
{\it{Установки -> Параметры\dots}}

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 55mm]{picture24.png}
  \end{center}
\end{figure}

\newpage
\noindent
и откроем вкладку <<Оцифровка>>:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 117mm]{picture25.png}
  \end{center}
\end{figure}

\noindent
Здесь нас интересуют три параметра для настройки. Первое - ширина Резиновой нити. Резиновая нить --- линия между курсором и вершинами (последней и начальной). Также можно настроить прилипание --- автоматическое нацеливание на вершину или сегмент между вершинами. И наконец, измените маркер на удобный Вам. Щёлкнув правой клавишей мыши по слою с будущими полигонами, зайдите на вкладку <<Стиль>> и измените значение прозрачности до 60--80\%, чтобы карта просвечивала через полигоны.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 117mm]{picture26.png}
  \end{center}
\end{figure}

\newpage
\vspace{6pt}
\noindent
Итак, наше рабочее пространство выглядит примерно так:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 135mm]{picture27.png}
  \end{center}
\end{figure}

\noindent
Отчётчиво видно, что граница Больхехцирского заповедника выделена зеленым цветом. Мысленно разделим эту область на регионы. Для перехода в режим редактирования нажмём на иконку с жёлтым карандашом в верхнем левом углу \ico{tool1.png}. Выберем инструмент {\it{Добавить объект}} \ico{tool2.png} и приступим к рисованию. Будет лучше, если вначале мы нарисуем большой полигон, покрывающий всю область, а затем поделим его на сектора. В противном случае между границами секторов могут быть пустоты, что некрасиво. Выделение образуется из опорных точек, которые ставятся левой клавишей мыши. 

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{picture28.png}
  \end{center}
\end{figure}

\newpage
\noindent
Чтобы закончить выделение, нужно нажать на правую клавишу. После нажатия, появится вот такое окно:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 30mm]{picture29.png}
  \end{center}
\end{figure}

\noindent
Пока его можно не заполнять, чтобы введённые значения не унаследовались всеми секторами, которые мы создадим инструментом {\it{Разбить объекты}} \ico{tool3.png}. А пока мы получили следующий результат:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 92mm]{picture30.png}
  \end{center}
\end{figure}

\noindent
Теперь нам нужно поделить большой полигон на части. Для начала, руководствуясь просвечивающей зеленой границей заповедника, отделим его. Затем, поделим два разных по типу региона на сектора. Для этого достаточно построить ломаную, чтобы она пересекала две уже существующие границы секторов, например вот так:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 92mm]{picture31.png}
  \end{center}
\end{figure}

\noindent
В результате мы получим несколько маленьких полигонов с общими границами (что было бы крайне трудноосуществимым, если бы полигоны рисовались отдельно друг от друга). Если объектов слишком много, то их можно объединить, выделив их инструментом на иконке (\ico{tool6.png}) и <<сшив>> Объединением \ico{tool7.png}. Нам осталось лишь внести данные. Для этого щёлкнем по иконке \ico{tool5.png} и нажмём на сектор. Появится панель <<Результат определения>>. Отметим флажок <<Открывать форму>>. Теперь, при щелчке по сектору, будет отображаться уже знакомое нам окно с вводом данных. Введём данные для всех объектов. В результате мы получим примерно такую таблицу атрибутов (data я вводил случайным образом, насколько это понятие применимо к человеку):

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 95mm]{picture32.png}
  \end{center}
\end{figure}

\noindent
Проверим наш результат в R:

<<zapoved, message = FALSE, warning = FALSE>>=
zapoved <- readOGR("Карты/Хабаровский_край", "mypolygons")
@
<<plot11, message = FALSE, warning = FALSE, echo = -c(1, 4), results = "hide">>=
cairo_pdf("plot11.pdf", pointsize = 20, height = 5)
par(mar = c(0, 0, 1, 0))
plot(zapoved)
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 60mm]{plot11.pdf}
  \end{center}
\end{figure}

\noindent
Как видим, получился уже привычный shape-файл с полигонами. Теперь отобразим имеющиеся на нём данные. Для этого мы воспользуемся новой для нас функцией {\texttt{spplot()}}, содержащейся в пакете {\bf{sp}}, который загружается вместе с пакетом {\bf{rgdal}}. В отличии от {\texttt{plot()}}  она не способна возвращать графики и диаграммы и предназначена исключительно для работы с пространственными данными. 

<<plot12, message = FALSE, warning = FALSE, echo = -c(1, 3), results = "hide">>=
cairo_pdf("plot12.pdf", pointsize = 25, width = 14, height = 8)
spplot(zapoved, "type", col.regions = c("#FE6A63", "#42BDFB"),
       par.settings = list(fontsize = list(text = 25)),
       scales = list(draw = TRUE))
dev.off()
@
\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{plot12.pdf}
  \end{center}
\end{figure}

\noindent
Мы получим знакомую нам карту, но уже с автоматически готовой легендой. Замечу, что при отображении важно указать отображаемую переменную (в нашем случае это type), иначе получим карты по всем переменным. Чтобы показать больше возможностей данной функции, сгенерируем ещё один вектор данных (столбец). Для этого, выполним следующие команды:

<<datagen, message = FALSE, warning = FALSE>>=
#Сгенерируем 9 случайных действительных чисел от 0 до 50
zapoved@data[, 5] <- runif(9, 0, 50)
names(zapoved@data)[5] <- "data2"
head(zapoved@data)
@

\noindent
Теперь у нас есть два набора данных. Построим график со сравнением (заодно удалим оси координат командой {\texttt{list(axis.line = list(col = NA))}}. Замечу, что в зависимости от заданного пространства для построения, график может быть как в одну, так и в несколько колонок, причем распределение и построение делается автоматически. Также стоит учесть, что количество цветов в палитре (в нашем случае это {\texttt{heat.colors()}}) должно соответствовать данным, поскольку шкалы для категорических (categoric), и числовых (целочисленных (integer) и непрерывных (continuous)) величин отличны, поэтому не стоит комбинировать карты с разными типами данных.

<<plot12_1, message = FALSE, warning = FALSE, echo = -c(1, 3), results = "hide">>=
cairo_pdf("plot12_1.pdf", pointsize = 25, width = 17, height = 7)
spplot(zapoved[c("data", "data2")], col.regions = heat.colors(50),
       par.settings = list(fontsize = list(text = 25),
                           axis.line = list(col = NA)))
dev.off()
@

\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 180mm]{plot12_1.pdf}
  \end{center}
\end{figure}
 
\noindent
Таким образом, мы получили две картограммы, позволяющие провести сравнение распределений {\bf{data}} и {\bf{data2}}.

\subsubsection{Получение административных границ регионов}
В отличие от данных, представленных точками или линиями, получение полигонов (а именно административных границ регионов) лучше осуществить другим способом. В противном случае, при попытке получить данные OSM с рабочей области, вмещающей в себя всю территорию государства (тем более такого, как Россия), придётся загрузить крайнне большое количество информации. Чтобы этого избежать, слой с границами можно получить напрямую с помощью плагина OSM Place search. В данном случае я буду получать границы районов Владивостокского городского округа (в связи с их небольшим количеством, а также для разнообразия примеров).

\vspace{6pt}
\noindent
Но сперва нам понадобится новый модуль, который даст нам дополнительные инструменты для работы со слоями, а именно объединение слоев в один shape-файл. Этот модуль называется MMQGIS, получить его можно тем же путём, что и другие модули. После установки он отобразится в виде отдельной вкладки меню:

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 100mm]{picture34.png}
  \end{center}
\end{figure}

\noindent
Далее я рекомендую установить систему координат проекта на WGS 84 (EPSG:4326). Объекты в этой системе могут показаться немного сплющенными, но в определении координат будут использоваться широта и долгота, что избавит нас от необходимости переопределять проекцию при работе с shape-файлом в R).

\vspace{6pt}
\noindent
И наконец, зайдя в меню 

\vspace{6pt}
{\it{Модули -> OSM place search\dots -> Configuration\dots}}

\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 100mm]{picture35.png}
  \end{center}
\end{figure}

\noindent
в поле Options вводим limit=50. Это даст нам больше результатов поиска и уменьшит шанс того, что искомого района не окажется среди выведенных.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 100mm]{picture36.png}
  \end{center}
\end{figure}

\noindent
Теперь можно приступить к получению административных границ. Для этого, аналогично тому, как мы это делали в предыдущих подсекциях, вводим имя искомого района в поле поиска панели {\bf{OSM place search\dots}} (для удобства в ориентировке можно подгрузить слой с картой OpenStreetMap, но учтите, что система координат сменится на WGS 84/Pseudo Mercator (EPSG:3857)). Обращаю Ваше внимание, что понятия <<Владивосток>> и <<Владивостокский городской округ>> отличны друг от друга, но для краткости будет <<Владивосток>>.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{picture37.png}
  \end{center}
\end{figure}

\noindent
Чтобы сохранить выделение как слой, щёлкнем по иконке \ico{tool8.png}, расположенной в нижней части панели. Если система координат по умолчанию отсутствует, то появится окно, в котором будет предложено её выбрать. Выбираем WGS 84 (или WGS 84/Pseudo Mercator, если используете карту OSM на фоне. В таком случае, если слой не отображается, щёлкаем по нему правой клавишей мыши и в {\it{Свойства -> Общие}} выбираем эту систему координат). Полученному слою лучше дать какое-нибудь имя и сделать полупрозрачным, он будет служить фоном для районов города.

\vspace{6pt}
\noindent
Аналогичным способом мы можем получить слои районов Владивостока (как и любого другого города или региона). Отмечу, что административные районы Владивостока не покрывают всю территорию Владивостокского городского округа, поэтому некоторые места могут отсутствовать (к примеру, острова на югу от материка и небольшая область соседствующая с Фрунзенским районом, отмечена на скриншоте ниже). В том редком случае, когда поиск не находит запрашиваемый район, убедитесь в следующем:

  \begin{itemize}
  
    \item Отсутствие опечаток
    \item Соответствие введённого значения официальному названию района (то есть, если вы хотите получить границы Ленинского            района, нужно вводить <<Ленинский район>>, так как одного лишь <<Ленинский>> недостаточно)
    \item В настройках модуля OSM place search в строке options указано limit=50
  
  \end{itemize}
  
\noindent
Если же все вышеперечисленные критерии выполнены, попробуйте ввести другое принятое название района (например, чтобы найти республику Северная Осетия, нужно ввести <<республика Северная Осетия - Алания>>), дополнить поиск (вместо <<Ленинский район>> ввести <<Ленинский район, Владивосток>>), увеличить лимит результатов поиска или же ввести имя региона на английском. Также можно попробовать приблизить карту и найти название района (в случае с нашим примером --- остров Елены) В крайнем случае границы можно отрисовать вручную: для этого на слое OpenStreetMap в достаточно большом масштабе нужно найти границы районов (фиолетовая пунктирная линия, как на скриншоте ниже). Замечу, что это очень трудоёмкий вариант.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{picture38.png}
  \end{center}
\end{figure}

\noindent
Получив слои границ всех районов города, при необходимости, нужно перевести их обратно в систему координат WGS 84 (EPSG:4326). Для этого щёлкнем по соответствующему полю в нижней правой стороне окна и выберем систему в открывшемся окне. Как мы можем заметить, теперь координаты измеряются в градусах:

\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{picture39.png}
  \end{center}
\end{figure}

\noindent
Чтобы сохранить слои, перейдём по вкладкам меню:

\vspace{6pt}
{\it{MMQGIS -> Combine -> Merge Layers}}

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 70mm]{picture40.png}
  \end{center}
\end{figure}

\noindent
В открывшемся окне выделяем нужные слои и выбираем директорию для экспорта shape-файла. Также он отобразится на панели слоев. Теперь можно открыть таблицу атрибутов слоя и отредактировать её на свое усмотрение. Напоследок, если при создании файла Вы использовали слои с проекцией Pseudo Mercator, то слой нужно сохранить с новой проекцией. Для этого, сперва убедитесь в том, что система координат проекта WGS 98, и затем, щёлкнув правой клавишей мыши по слою файла и выбрав <<Сохранить как>>, из списка систем координат выберите WGS 84 (EPSG:4326) и нажмите ОК.

\vspace{6pt}
\noindent
В R результат выглядит следующим образом (в QGIS я подредактировал имена районов для компактности легенды):

\newpage
<<vlad, message = FALSE, warning = FALSE>>=
vlad <- readOGR("Карты", "vlad")
vlad.df <- fortify(vlad, region = "name")
@
<<plot_vlad, message = FALSE, warning = FALSE, echo = -c(1, 3), results = "hide">>=
cairo_pdf("plot_vlad.pdf", pointsize = 25, width = 12, height = 8)
  ggplot(vlad.df, 
         aes(long, lat, group = group, fill = id)) +
  geom_polygon() + plot5theme
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 100mm]{plot_vlad.pdf}
  \end{center}
\end{figure}

\subsubsection{Упрощение карт}
В данной подсекции пойдёт речь о картографической генерализации\footnote{{\bf{Картографическая генерализация}} --- упрощение карты в рамках её цели.}, а именно об упрощении границ (другими словами, об упрощении геометрии слоёв границ). Это актуально для тех случаев, когда на карте (или картограмме) большое число полигонов или излишне подробная граница для целевого масштаба. В этих случаях полигоны, изображающие границы регионов, содержат большое количество вершин, данные координат которых необходимо обработать при прорисовке, замедляя составление картограмм. С технической точки зрения, процесс упрощения границ состоит в том, что необходимо удалить часть этих вершин. В качестве примера я возьму файл с границами субъектов Федерации из проекта OSM в формате geoJSON с сайта GISGeo (\url{http://gisgeo.org/index.php?id=7#GovOpen}), поскольку это достаточно большой (27Мб) файл, который весьма долго обрабатывается в R и, следовательно, требует упрощения. Для упрощения я буду использовать QGIS, однако замечу, что существуют другие варианты генерализации карт\footnote{Использовать GRASS или функцию {\texttt{thinnedSpatialPoly()}} в R.}.

\vspace{6pt}
\noindent
Загрузим файл и откроем его в QGIS, как слой ({\it{Слой -> Добавить слой -> Добавить векторный слой\dots}}). 

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{picture41.png}
  \end{center}
\end{figure}

\noindent
Как и прошлой подсекции, убедитесь в том, что система координат слоя WGS 84. Теперь выполним упрощение границ, для этого перейдём по вкладкам меню:

\vspace{6pt}
{\it{Вектор -> Обработка геометрии -> Упростить геометрию\dots}}

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{picture42.png}
  \end{center}
\end{figure}

\noindent
В открывшемся окне выбираем слой, геометрию которого мы хотим упростить и порог упрощения. Последний зависит от системы координат, в которой загружен слой, то есть, в случае с WGS 84, в которой координаты измеряются в градусах, порог 0.1 будет означать одну десятую градуса, что в зависимотсти от широты может составлять от 111 км до 0 км. То есть, выбрав в качестве порога 0.1 мы удалим все вершины, расстояние между которыми меньше чем 0.1\degree. От себя замечу, что в R достаточно быстро обрабатываются файлы с 10000--15000 точками (в зависимости от вычислительной мощности компьютера), поэтому стоит выбрать значение, которое сократит количество вершин до этого числа. В нашем случае это около 0.07. Результат сохраним в shp (за отсутствием выбора) и добавим в проект.

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 80mm]{picture43.png}
  \end{center}
\end{figure}

\noindent
Отмечу, что данный способ генерализации не идеален, так как упрощает полигоны по-отдельности, тем самым создавая щели между ними. Однако, при определённом масштабе это будет незаметно, а потери оправдают себя уменьшенной скоростью прорисовки. В любом случае, полученный слой сохраняем в формате geoJSON (не забудьте о системе координат). Назовём его <<russia.geojson>>. Размер файла с границами существенно уменьшился: теперь он занимает всего 434Кб. 

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 70mm]{picture44.png}
  \end{center}
\end{figure}

\noindent
Проверим его в R. 

<<json.file, message = FALSE, warning = FALSE>>=
json.file <- readOGR("Карты/geojson/russia.geojson", "OGRGeoJSON")
@

<<plot_json1, message = FALSE, warning = FALSE, echo = -c(1, 4), results = "hide">>=
cairo_pdf("plot_json1.pdf", pointsize = 25)
par(mar = c(0,0,1,0))
plot(json.file, main = "Карта России")
dev.off()
@


\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 90mm]{plot_json1.pdf}
  \end{center}
\end{figure}

\noindent
У нас получилась вполне корректная карта, но поскольку Чукотка и остров Врангеля пересекают 180\degree меридиан, по правилам системы координат её разрезает на две части, что портит вид карты и представляет её в меньшем масштабе. Этот недостаток можно исправить непосредственно в R с помощью следующего блока команд, который я для воспроизводимости преобразовал в функцию 
(команды для <<сшивания>> Чукотки взяты отсюда: \url{https://github.com/Sobach/R.rus.map.zoom/blob/master/mapzoom.R}). Также эти функции доступны в пакете rusmaps:

<<func, message = FALSE, warning = FALSE>>=
#Данная функция исправляет отрицательные значения координат,
#преобразуя их в положительные
longitude_correction <- function(x) {
  if (x < 0) {
    x <- 359.999 + x
  }
  
  return(x)
}

#Данная функция принимает объект SpatialPolygonsDataFrame
#и "сшивает" полигоны, пересекающие 180 меридиан
restore180 <- function(y) {
  for (i in 1:length(y@polygons)) {
    for (j in 1:length(y@polygons[[i]]@Polygons)) {
      y@polygons[[i]]@Polygons[[j]]@coords[, 1] <- sapply(
        y@polygons[[i]]@Polygons[[j]]@coords[, 1], 
        longitude_correction)
    }
  }
  return(y)
}
@


<<plot_json, message = FALSE, warning = FALSE, echo = -c(3, 7), results = "hide">>=
#Чтобы сэкономить пространство, соединим Чукотку воедино
json.file <- restore180(json.file)
cairo_pdf("plot_json.pdf", pointsize = 25, width = 20, height = 8)
json.map <- fortify(json.file, region = "ADM3_NAME")
rus.map <- ggplot(json.map, 
                  aes(long, lat, group = group, fill = id)) + 
           geom_polygon(alpha = 0.7)
rus.map + plot5theme
dev.off()
@



\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{plot_json.pdf}
  \end{center}
\end{figure}

\noindent
У нас получилась достаточно детализированная и быстро загружающаяся карта.

\vspace{6pt}
\noindent
Также качестве альтернативы можно использовать \url{mapshaper.org} или другие веб-сервисы. Mapshaper, помимо конвертации, позволяет осуществить упрощение карты разными методами (алгоритмами). Для этой цели есть кнопка <<simplify>> в верхней правой части окна. Есть возможность выбрать степень упрощения с помощью ползунка. 

\newpage
\section{Визуализация экономических данных}
В данной секции пойдёт речь о способах визуализации пространственных данных. До этого момента мы создавали карты и легенды по категорическим данным (названиям районов и банков). Но помимо имени объект может представлять и какую-то численную информацию, которую нужно отобразить в рамках исследования. Для разных данных можно использовать разные способы. С некоторыми из них Вы можете ознакомиться ниже.

\subsection{Построение карт с градиентом}
Градиент лучше всего подходит для непрерывных и целочисленных данных с большим размахом, поскольку без объединения таких данных в группы их нельзя поделить на категории. В качестве примера мы рассмотрим распределение населения по Центральному федеральному округу.

<<centpop, message = FALSE, warning = FALSE>>=
centpop <- readOGR("Карты/Федеральные_округа", "ЦФО")
@
<<plot_grad, message = FALSE, warning = FALSE, echo = -c(5, 7), results = "hide">>=
library("scales") #Представит метки легенды в целочисленном виде
pop.df <- fortify(centpop, region = "name")
pop.df <- merge(pop.df, centpop@data, by.x = "id", by.y = "name")
pop.map <- ggplot(pop.df, aes(long, lat, group = group, fill = pop_2016)) +
           geom_polygon(color = "white", alpha = 0.5) +
           coord_map() +
           labs(x = "Долгота", y = "Широта",
                fill = "Численность населения") +
           ggtitle("Численность населения ЦФО в 2016 году") +
           scale_fill_gradient(low = "blue", high = "red", labels = comma)
cairo_pdf("plot_grad.pdf", pointsize = 25, width = 12, height = 8)
pop.map + plot5theme
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{plot_grad.pdf}
  \end{center}
\end{figure}

\noindent
Как мы можем заметить, больше всего населения приходится на Московскую область и город Москва.

\subsection{Построение карт с точечными данными}
В случаях, когда данные представлены в виде точек, имеет смысл отобразить их размер в зависимости от величин данных, которые они содержат. Рассмотрим пример с населенем городов миллионеров: 

<<citypop, message = FALSE, warning = FALSE>>=
citypop <- readOGR("Карты/Города_миллионники", "города миллионники")
russia <- readOGR("Карты/Россия/w_fd", "рос_фо")
@
<<plot_size, message = FALSE, warning = FALSE, echo = -c(1, 15), results = "hide">>=
cairo_pdf("plot_size.pdf", pointsize = 25, width = 12, height = 10) 
rus.df <- fortify(russia, region = "id")
city.df <- as.data.frame(citypop@data)

city.coords <- as.data.frame(citypop@coords)
city.df[, 4] <- city.coords$coords.x1
city.df[, 5] <- city.coords$coords.x2
names(city.df)[4] <- "coords.x"
names(city.df)[5] <- "coords.y"

#geom_text добавит подписи к точкам
citypop.map <- ggplot(rus.df) +
               geom_polygon(color = "white", fill = "#7eb92d", 
                            aes(long, lat, group = group)) +
               geom_point(data = city.df, 
                          aes(coords.x, coords.y, size = pop_2015), 
                          color = "#b92f51", alpha = 0.7) +
               geom_text(data = city.df, angle = 45,
                          aes(coords.x, coords.y, label = name)) +
               coord_map(xlim = c(0, 100),
                         ylim = c(40, 70)) +
               labs(x = "Долгота", y = "Широта", 
                    size = "Численность населения") +
              scale_size(labels = comma) +
               ggtitle("Численность населения в городах миллионерах в 2015 году") +
               theme(plot.title = element_text(hjust = 1, vjust = 1.5))

citypop.map
dev.off()
@

\newpage
\begin{figure}[t]
  \begin{center}
    \includegraphics[width = 180mm]{plot_size.pdf}
  \end{center}
\end{figure}

\subsection{Построение карт с уровнями}
Уровни нужны в случаях, когда есть необходимость показать плотность распределения данных. В нашем случае, мы можем использовать уже известные нам данные о местоположении банков в Хабаровске. Воспользуемся следующими командами:

<<plot_density, message = FALSE, warning = FALSE, echo = -c(1, 5), results = "hide">>=
cairo_pdf("plot_density.pdf", pointsize = 25, width = 12, height = 8)
levelmap <- ggplot() +
  geom_polygon(data = map.df, alpha = 0.7, color = "white",
               aes(long, lat, group = group, fill = id)) +
  geom_point(data = khab.banks.df, 
             aes(coords.x, coords.y), size = 3) +
  geom_density2d(data = khab.banks.df, 
                 aes(coords.x, coords.y)) +
  coord_map(xlim = c(134.85, 135.25)) +
  labs(x = "Широта", y = "Долгота", 
       fill = "Название района") +
  ggtitle("Банки в г.Хабаровск") 

levelmap + plot5theme
dev.off()
@

\newpage
\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{plot_density.pdf}
  \end{center}
\end{figure}

\subsection{Сравнение двух регионов}
Имеет место быть случай, когда необходимо сравнить два региона. В таком случае, нам понадобится пакет {\bf{gridExtra}}, который позволяет разместить карты и графики по нескольким столбцам и(или) строкам. Чтобы это осуществить, нам понадобятся следующие команды:

<<prep, message = FALSE, warning = FALSE>>=
uralpop <- readOGR("Карты/Федеральные_округа", "УФО")
pop.df1 <- fortify(uralpop, region = "name")
pop.df1 <- merge(pop.df1, uralpop@data, by.x = "id", by.y = "name")
#При условии одинаковой заливки, легенду у одной из карт можно убрать
pop.map1 <- ggplot(pop.df1, aes(long, lat, group = group, fill = pop_2016)) +
  geom_polygon(color = "white") +
  coord_map() +
  labs(x = "Долгота", y = "Широта",
       fill = "Численность населения") +
  ggtitle("Численность населения в 2016 году") +
  theme(legend.position = "none")

volgapop <- readOGR("Карты/Федеральные_округа", "ПФО")
pop.df2 <- fortify(volgapop, region = "name")
pop.df2 <- merge(pop.df2, volgapop@data, by.x = "id", by.y = "name")

pop.map2 <- ggplot(pop.df2, aes(long, lat, group = group, fill = pop_2016)) +
  geom_polygon(color = "white") +
  coord_map() +
  labs(x = "Долгота", y = "Широта",
       fill = "Численность населения") +
  scale_fill_gradient(labels = comma) +
  ggtitle("Численность населения в 2016 году") 
@
<<plot_comp, message = FALSE, warning = FALSE, echo = -c(1, 3), results = "hide">>=
cairo_pdf("plot_comp.pdf", pointsize = 25, width = 12, height = 8)
grid.arrange(pop.map1, pop.map2, ncol = 2)
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{plot_comp.pdf}
  \end{center}
\end{figure}

\subsection{Сравнение наборов точечных данных}
Рассмотрим такой случай: у нас есть два набора данных по количеству мест в кафе сети Шоколадница и кафе сети Starbucks. Эти данные можно разделить на две группы, и чтобы нам была понятна принадлежность кафе к первой или второй группе, точки нужно закрасить соответствующими цветами. Количество мест же можно отобразить с помощью размера точки. 

<<plot_2data, message = FALSE, warning = FALSE, echo = -c(1, 23), results = "hide">>=
cairo_pdf("plot_2data.pdf", pointsize = 25, width = 12, height = 10)
#Допустим, что данные coffee1 и mosmap уже есть
#Переименуем (чтобы не терять данные) NA значения
coffee1@data[is.na(coffee1@data)] <- "Unknown"
shoko <- coffee1[coffee1@data$OperatingCompany == "Шоколадница", ]
starbucks <- coffee1[coffee1@data$OperatingCompany == "Старбакс", ]
#Создадим dataframes для каждого набора точек
shoko.coords <- as.data.frame(shoko@coords)
shoko.df <- as.data.frame(shoko@data)
shoko.df[, 6] <- shoko.coords[, 1]
shoko.df[, 7] <- shoko.coords[, 2]
names(shoko.df)[6] <- "coords.x"
names(shoko.df)[7] <- "coords.y"
starbucks.coords <- as.data.frame(starbucks@coords)
starbucks.df <- as.data.frame(starbucks@data)
starbucks.df[, 6] <- starbucks.coords[, 1]
starbucks.df[, 7] <- starbucks.coords[, 2]
names(starbucks.df)[6] <- "coords.x"
names(starbucks.df)[7] <- "coords.y"
mosmap.df <- fortify(mosmap, region = "NAME")
coffee.points <- ggplot() +
                geom_polygon(data = mosmap.df, fill = "white",
                             aes(long, lat, group = group), 
                             color = "black") +
                geom_point(data = shoko.df, alpha = 0.6, 
                          aes(coords.x, coords.y, size = SeatsCount, 
                              color = OperatingCompany)) +
                geom_point(data = starbucks.df, alpha = 0.6,
                          aes(coords.x, coords.y, size = SeatsCount, 
                              color = OperatingCompany)) +
                labs(x = "Долгота", y = "Широта", 
                color = "Кофейня", size = "Количество мест") +
                scale_color_manual(values = c("green", "red"), 
                                   labels = c("Starbucks", "Шоколадница")) +
                ggtitle("Количество мест в кофейнях Москвы")
coffee.points + plot5theme
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{plot_2data.pdf}
  \end{center}
\end{figure}

\noindent
Также можно использовать градиент для этих целей. Как и в предыдущем случае, нужно разделить точки на две группы: первую, к точкам которой будет применяться заливка, и вторую, точки которой будут иметь лишь внешний цветной контур (в случае небольшого размаха лучше выбрать контрастные цвета, также стоит сделать разные формы для точек в случае есди они будут сероватого цвета). В таком случае наша команда выглядит следующим образом:

<<plot_2data_2, message = FALSE, warning = FALSE, echo = -c(1, 4), results = "hide">>=
cairo_pdf("plot_2data_2.pdf", pointsize = 25, width = 12, height = 10)
coffee.2grad <- ggplot() +
                geom_polygon(data = mosmap.df, fill = "white",
                             aes(long, lat, group = group), color = "black") +
                coord_map(xlim = c(37.25, 38),
                         ylim = c(55.50, 56)) +
                geom_point(data = shoko.df, size = 3, alpha = 0.5,
                          aes(coords.x, coords.y, color = SeatsCount, shape = "19")) +
                geom_point(data = starbucks.df, size = 3, alpha = 0.5,
                          aes(coords.x, coords.y, fill = SeatsCount, shape = "22")) +
                scale_color_gradient(low = "#00ffff", high = "#ff0400", 
                                     name = "Число мест в Шоколадницах") +
                scale_fill_gradient(low = "#ff00dc", high = "#00ff19", 
                                    name = "Число мест в Starbucks") +
                scale_shape_manual(values = c(19, 22),
                                   labels = c("Шоколадница", "Starbucks"),
                                   name = "Сеть кофеен") +
                labs(x = "Долгота", y = "Широта") +
                ggtitle("Количество мест в кофейнях Москвы")
coffee.2grad + plot5theme
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{plot_2data_2.pdf}
  \end{center}
\end{figure}

\noindent
Если же есть необходимость сравнить точки из более чем двух групп, мы можем использовать команды первого примера. Однако, полученную в результате картограмму сложно читать, и она будет намного полезнее, если сделать её интерактивной, например в plot\_ly.

<<plot_2data_3, message = FALSE, warning = FALSE, echo = -c(1, 10), results = "hide">>=
cairo_pdf("plot_2data_3.pdf", pointsize = 20, width = 20, height = 17)
coffee2.coords <- as.data.frame(coffee1@coords)
coffee2.df <- as.data.frame(coffee1@data)
coffee2.df[, 6] <- coffee2.coords[, 1]
coffee2.df[, 7] <- coffee2.coords[, 2]
names(coffee2.df)[6] <- "coords.x"
names(coffee2.df)[7] <- "coords.y"
coffee.groups <- ggplot() +
                 geom_polygon(data = mosmap.df, fill = "white",
                              aes(long, lat, group = group), color = "black") +
                 coord_map(xlim = c(37.25, 38),
                           ylim = c(55.50, 56)) +
                 geom_point(data = coffee2.df,
                           aes(coords.x, coords.y, size = SeatsCount,
                               color = OperatingCompany)) +
                 labs(x = "Долгота", y = "Широта", 
                      color = "Кофейни", size = "Число мест") +
                 ggtitle("Количество мест в кофейнях Москвы")
coffee.groups + plot5theme + theme(legend.position = "bottom")
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{plot_2data_3.pdf}
  \end{center}
\end{figure}

\newpage
\subsection{Отображение изменений на картах}
Допустим, нам нужно сделать сравнение численности населения в Хабаровском крае за 2015 и 2016 года. Как вариант, мы можем построить две карты с помощью {\bf{gridExtra}}. Но это занимает много места, и по цвету градиента не всегда ясно, изменилась ли численность или нет. В таком случае можно восползоваться функцией {\texttt{plot()}}, добавиви в неё цикл {\texttt{for}}:

<<khab3, message = FALSE, warning = FALSE>>=
khab3 <- readOGR("Карты/Хабаровский_край", "Хабаровск")
@
<<plot_change1, message = FALSE, warning = FALSE, echo = -c(1, 7), results = "hide">>=
cairo_pdf("plot_change1.pdf", pointsize = 12)
par(mar = c(0, 0, 1, 0))
plot(khab3, main = "Изменение численности населения в Хабаровском крае")
khab3$id <- 1:length(khab3@data$id) 
for (i in 1:length(khab3@data$id)) {
    if (khab3@data$pop_2015[i] < khab3@data$pop_2016[i]) {
      plot(khab3[khab3$id == i, ], col = "green", add = TRUE)
    }
    else(plot(khab3[khab3$id == i, ], col = "red", add = TRUE))
}
legend("right", c("Уменьшилось", "Увеличилось"), 
       bg = "transparent", box.lty = 0,
       fill = c("red", "green"), 
       title = "Численность населения", 
       cex = 1.5, title.adj = 0.22)
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 100mm]{plot_change1.pdf}
  \end{center}
\end{figure}

\noindent
Теперь мы видим, что почти в всех муниципальных районах Хабаровского края по сравнению в 2015 годом население упало. Но из картограммы нельзя узнать {\bf{насколько}} оно упало. Для этой цели нам пригодится трёхцветная градиентная заливка {\texttt{scale\_gradient2()}}, которую мы применим к объекту ggplot2:

<<plot_mapch, message = FALSE, warning = FALSE, echo = -c(1, 11), results = "hide">>=
cairo_pdf("plot_mapch.pdf", pointsize = 25, width = 12, height = 8)
khab3@data[, 6] <- khab3@data$pop_2016 - khab3@data$pop_2015
names(khab3@data)[6] <- "difference"

khabch.map <- fortify(khab3, region = "name")
khabch.map <- merge(khabch.map, khab3@data, by.x = "id", by.y = "name")

mapch <- ggplot() +
         geom_polygon(data = khabch.map, color = "white", 
                      aes(long, lat, group = group, fill = difference)) +
         coord_map() +
         labs(x = "Широта", y = "Долгота", fill = "Изменение численности") +
         scale_fill_gradient2(low = "#fe1529", mid = "white", high = "#6fff05") +
         ggtitle("Хабаровский край")

mapch + plot5theme
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{plot_mapch.pdf}
  \end{center}
\end{figure}

\noindent
Такой подход делает картограмму более информативной: теперь нам очевидно, что большие изменения численности коснулись южных районов края.

\vspace{6pt}
\noindent
Аналогично можно сдлелать и с точечными данными. Здесь нам пригодятся точки форм 24 и 25 (задаются с помощью {\texttt{pch =}} или {\texttt{shape =}}, представляют из себя стрелочки вверх и вниз). Разберём пример, создав случайные данные по посещаемости отделений Сбербанка (Сбербанк взят в качестве примера, поскольку насчитывает достаточно большое количество отделений):

<<plot_pchange, message = FALSE, warning = FALSE, echo = -c(1, 14), results = "hide">>=
cairo_pdf("plot_pchange.pdf", pointsize = 25, width = 18, height = 14)
#Зададим значения посещаемости банков до и после некоторого нововведения:
khab.banks.df[, 6] <- sample(120:200, length(khab.banks.df$name))
khab.banks.df[, 7] <- sample(130:220, length(khab.banks.df$name))
names(khab.banks.df)[6] <- "before"
names(khab.banks.df)[7] <- "after"
khab.banks.df[, 8] <- khab.banks.df$after - khab.banks.df$before
names(khab.banks.df)[8] <- "difference"
Sber <- khab.banks.df[khab.banks.df$name == "Сбербанк", ]
mapsource_p <- get_map(location = c(lon = 135.1, lat = 48.48), 
                       zoom = 13, source = "google")
pchange <- ggmap(mapsource_p) +
           geom_point(data = Sber, size = 8,
                      aes(coords.x, coords.y, 
                          shape = factor(difference < 0),
                          fill = factor(difference < 0))) +
           geom_label(data = Sber, nudge_x = 0.005, size = 7,
                      aes(coords.x, coords.y, label = difference)) +
           scale_shape_manual(name = "Изменение в посещаемости:",
                              values = c(24, 25),
                              labels = c("Возрасло", "Упало")) +
           scale_fill_manual(name = "Изменение в посещаемости:",
                             values = c("green", "red"),
                             labels = c("Возрасло", "Упало")) +
           labs(x = "Широта", y = "Долгота") +
           ggtitle("Изменения посещаемости отделений Сбербанка в г.Хабаровск")

pchange + plot5theme + theme(legend.position = "bottom")
dev.off()
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 150mm]{plot_pchange.pdf}
  \end{center}
\end{figure}

\noindent
На карте отчётливо видно, как и насколько изменилась посещаемость отделений банка!

\newpage
\subsection{Построение интерактивных карт}
В этой подсекции мы разберёмся, как пользоваться пакетами {\bf{leaflet}} и {\bf{plotly}}, которые позволяют делать интерактивные карты. Сама интерактивность будет доступна в Rstudio, где можно будет увеличить/уменьшить масштаб карты, перетаскивать её, и посмотреть на место расположение точек (в нашем случае банков) вплоть до улицы, а также получить подробные данные, содержащиеся в этих точках.

\subsubsection{Создание карт с leaflet}
{\bf{Leaflet}}\footnote{Подробнее на \url{http://leafletjs.com}} --- библиотека javascript с открытым исходным кодом, предназначенная для создания интерактивных карт, которые можно поместить на веб-страницу. Поддерживает мобильные приложения. Также существует пакет leaflet для R. С ним мы и будем работать.

\vspace{6pt}
\noindent
Чтобы в pdf документе появилось изображение карты (web-скриншот), понадобятся пакеты {\bf{webshot}} и {\bf{htmlWidgets}}. Работу первого мы настроили в секции <<Подготовка>> (заранее замечу, что для работы leaflet необходимо подключение к Интернету, и в случае падения скорости, карта может не прогрузиться полностью).

<<plot13, message = FALSE, warning = FALSE>>=
#Создание карты
khab.map.leaf <- leaflet() %>%
                 addTiles() %>% 
                 addPolygons(data = khab2) %>% #Добавим границы районов
                 addMarkers(data = khab.banks) #Добавим маркеры (точки) - координаты банков
#Сохранение карты
saveWidget(khab.map.leaf, "temp.html", selfcontained = FALSE)
webshot("temp.html", file = "plot13.pdf",
        cliprect = "viewport") 
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 100mm]{plot13.pdf}
  \end{center}
\end{figure}

\noindent
Таким образом, мы построили интерактивную карту, которая показывает границы районов Хабаровска и местоположения банков. Будет неплохо если мы её улучшим: к примеру, изменим масштаб и добавим всплывающие подсказки (popups). Для этого введём вот такую команду:

<<plot14, message = FALSE, warning = FALSE>>=
khab.map.leaf2 <- leaflet() %>%
                  addTiles() %>% 
                  addPolygons(data = khab2) %>%
                  addMarkers(data = khab.banks, popup = ~name) %>%
  #lng и lat задают центр карты, zoom - чем больше значение, тем сильнее увеличение
                  setView(lng = 135.07071, lat = 48.48002, zoom = 16)

saveWidget(khab.map.leaf2, "temp2.html", selfcontained = FALSE)
webshot("temp2.html", file = "plot14.pdf",
        cliprect = "viewport")
@

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{plot14.pdf}
  \end{center}
\end{figure}

\noindent
Теперь, если навести курсор на маркер, то мы получим всплывающее сообщение (в данном случае это название банка):

\begin{figure}[bh]
  \begin{center}
    \includegraphics[width = 120mm]{picture20.png}
  \end{center}
\end{figure}

\subsubsection{Создание карт с plotly}
{\bf{Plotly}} --- очень мощный инструмент для интерактивной визуализации данных, способен работать не только с картами (чем мы занимаемся в рамках этой работы), но и с обычными графиками, гистограммами и диаграммами. Для работы требуется подключение к Интернету, так как создание инфографики происходит с помощью Вашей учётной записи plotly. Чтобы вывести полученный результат в pdf, нужно выполнить кое-какие настройки окружения:

<<plotly_setup, message = FALSE, warning = FALSE>>=
Sys.setenv("plotly_username" = "ИМЯ ПОЛЬЗВАТЕЛЯ")
#Ключ API можно найти на странице своего аккаунта на вкладке "API KEYS"
Sys.setenv("plotly_api_key" = "КЛЮЧ API")
@

<<plotly_disc, message = FALSE, warning = FALSE, echo = FALSE>>=
Sys.setenv("plotly_username" = "akondrashov96")
#Ключ API можно найти на странице своего аккаунта на вкладке "API KEYS"
Sys.setenv("plotly_api_key" = "i4b879nbyl")
@

\noindent
Начнём с крайне полезной возможности plotly --- конвертации объектов ggplot в объекты plotly. То есть, имея график или карту, созданную с помощью {\texttt{ggplot()}} (но не {\texttt{ggmap()}}), можно вывести её в интерактивном виде через {\texttt{ggplotly()}}. Для этого (при условии, что у Вас уже есть карта Хабаровска), введём следующую команду:

<<plot15, message = FALSE, warning = FALSE>>=
khab.map.plotly <- ggplotly(khab.map + plot5theme)
plotly_IMAGE(khab.map.plotly, width = 1200, height = 800,
             format = "png", out_file = "plot15.png")
@

 \begin{figure}[bh]
   \begin{center}
     \includegraphics[width = 100mm]{plot15.png}
   \end{center}
 \end{figure}
 
\noindent
Карта на рисунке похожа на ту, что мы получили в помощью {\texttt{ggplot()}}, но с некоторыми упрощениями. Теперь, добавим в карту координаты банков. Для этого нам нужно будет немного видоизменить объект {\bf{khab.bank.map}}. Замечу, что параматр {\texttt{aes()}}, в который задаёт {\bf{fill (заливку)}} для полигонов и {\bf{color (цвет)}} для точек участвует в создании легенды, поэтому, чтобы в легенде были корректно указаны разные объекты, не стоит создавать единый {\texttt{aes()}} в команде {\texttt{ggplot()}} по Назовём новый объект {\bf{khab.bank2}}:

<<plot16, message = FALSE, warning = FALSE>>=
khab.bank2 <- ggplot(map.df) +
            geom_polygon(color = "white", alpha = 0.5, 
                         aes(long, lat, group = group, fill = id)) +
            geom_point(data = khab.banks.df, 
                       aes(coords.x, coords.y, color = name), 
                       size = 3, alpha = 0.7) +
            labs(x = "Широта", y = "Долгота",
                 color = NULL, fill = NULL) +
            ggtitle("Хабаровск")

khab.banks.plotly <- ggplotly(khab.bank2 + plot5theme)
plotly_IMAGE(khab.banks.plotly, width = 1380, height = 920,
             format = "png", out_file = "plot16.png")
@

 \begin{figure}[bh]
   \begin{center}
     \includegraphics[width = 120mm]{plot16.png}
   \end{center}
 \end{figure}
 
\noindent
В карте можно убирать ненужные элементы, щёлкнув по ним на легенде, а при наведении курсора появится детальная информация, содержащаяся в объекте (например, наведя курсор на точку, мы получим её координаты и название банка, который эта точка отмечает.)

  \begin{figure}[bh]
   \begin{center}
     \includegraphics[width = 140mm]{picture33.png}
   \end{center}
  \end{figure}
  
\noindent
Как я уже отметил в одной из предыдущих подсекций, некоторые картограммы могут быть настолько загруженными, что их пригодность можно спасти интерактивностью, как например с картой кофеен в Москве ({\bf{coffee.groups}}). 

<<plot17, message = FALSE, warning = FALSE>>=
coffee.groups <- ggplot() +
  geom_polygon(data = mosmap.df, fill = "white",
               aes(long, lat, group = group), color = "black") +
  coord_map(xlim = c(37.25, 38),
            ylim = c(55.50, 56)) +
  geom_point(data = coffee2.df, shape = 21,
             aes(coords.x, coords.y, size = SeatsCount,
                 color = OperatingCompany)) +
  labs(x = "Долгота", y = "Широта",
       color = NULL, size = NULL)
  ggtitle("Количество мест в кофейнях Москвы")

coffee.groups.plotly <- ggplotly(coffee.groups + plot5theme)
plotly_IMAGE(coffee.groups.plotly, width = 1380, height = 920,
             format = "png", out_file = "plot17.png")
@
  
   \begin{figure}[bh]
   \begin{center}
     \includegraphics[width = 120mm]{plot17.png}
   \end{center}
 \end{figure}
 
\noindent
Так наша карта стала намного полезнее!
 
\vspace{6pt}
\noindent
Согласно нашему опыту, мы можем вывести небольшое заключение: leaflet удобен в случаях, когда нужно просто отобразить данные с привязкой к карте, в то время как plotly создаёт схематичные карты, с привязкой данных непосредственно к объектам изучения - регионам, областям и так далее. Оба пакета просты в использовании, но совместимость ggplot2 с plotly несомненно, даёт последнему существенный перевес.

\newpage
\section{О пакете rusmaps}
К данной работе прилагается пакет {\bf{rusmaps}}, разработанный мною при поддержке моего научного руководителя, Бориса Демешева. Этот пакет предназначен для работы в R и содержит в себе готовый набор shape-файлов, среди которых есть:

  \begin{itemize}
    
    \item Города-миллионеры (согласно данным Википедии):
          
          \begin{trivlist}
            
            \item Москва  (2015, 2016)
            \item Санкт-Петербург (2015, 2016)
            \item Новосибирск (2016)
            \item Екатеринбург (2015)
            \item Нижний Новгород (2015)
            \item Казань (2015)
            \item Челябинск (2015)
            \item Омск (2010)
            \item Самара (2015)
            \item Ростов-на-Дону
            \item Уфа (2015)
            \item Красноярск (2010)
            \item Пермь (2015)
            \item Воронеж (2010)
            \item Волгоград (2015)
            
          \end{trivlist}
        
      \item Федеральные округа (с субъектами Федерации, данные по оценке численности населения даны за 2015 и 2016)
      
          \begin{trivlist}
          
            \item Центральный федеральный округ
            \item Северно-Западный федеральный округ
            \item Южный федеральный округ
            \item Северо-Кавказский федеральный округ
            \item Приволжский федеральный округ
            \item Уральский федеральный округ
            \item Сибирский федеральный округ
            \item Дальневосточный федеральный округ
            \item Крымский федеральный округ
          
          \end{trivlist}
          
      \item Российская Федерация в целом (доступны версии с Крымом и без)
      
          \begin{trivlist}
            
            \item С федеральными округами
            \item С субъектами Федерации
            
          \end{trivlist}
          
      \item Хабаровский край (2016)
      
    \end{itemize}
    
\noindent
Содержащиеся в данных городов полигоны были получены с помощью QGIS и модулей OSM Place Search и OpenLayers. Это же касается и данных по Хабаровскому краю. Подробную инструкцию Вы можете прочитать в подсекции <<Получение административных границ регионов>>. В файлах переименованы некоторые районы, для соответствия официальным названиям. Также были добавлены данные по оценке численности населения на 1 января 2010, 2015 и 2016 годов (указано в скобках), взятые с сайта Росстат: \url{www.gks.ru} и его региональных филиалах. Данные федеральных округов и субъектов федерации были получены с ресурса: \url{http://gis-lab.info/qa/osm-adm.html} (файлы с обрезкой по береговой линии). Таблицы данных изменены и дополнены аналогично таблицам файлов городов.

\vspace{6pt}
\noindent
Репозиторий пакета можно найти по следующему адресу: \url{https://github.com/akondrashov96/rusmaps}.

\vspace{6pt}
\noindent
Для загрузки пакета понадобится следующая команда:
<<pkg_dwl, message = FALSE, warning = FALSE, eval = FALSE>>=
devtools::install_github("akondrashov96/rusmaps")
library("rusmaps")
@

\noindent
Теперь, подключив пакет rusmaps, можно использовать его данные для создания картограмм.

\newpage
\section{Заключение}
В данной работе я рассмотрел и привёл примеры получения и визуализации данных на картах. Также, в рамках этой работы я разработал пакет {\bf{rusmaps}}, в который включил границы территорий городов и регионов России. Возможности визуализации пространственных данных в R на настоящий момент достаточно развиты и способны решить широкий спектр задач. Тем не менее, это не мешает создавать новые инструменты, в том числе и пакеты данных, для упрощения работы и дальнейшего расширения среды R в этой области. Кроме того, разумным решением станет использовать QGIS в паре с R: во-первых, QGIS это тоже свободно распространяемое ПО, функционал которого можно расширять посредством различных модулей, а во-вторых, это экономит время: в QGIS многие задачи решаются просто и быстро несколькими щелчками мышью, тогда как в R может возникнуть необходимость разбираться в новых командах, что может занять много времени. Выражаю надежду, что читатели данной работы найдут её полезной и смогут с лёгкостью использовать R для своих исследовательских нужд.


\newpage
\begin{table}
\section{Приложение 1}

\vspace{6pt}
{\large{\bf{Административные уровни регионов России}}}

\vspace{6pt}
\noindent
Каждый регион обладает определённым административным уровнем, который определяет тип этого региона согласно применяемому в той или иной стране территориальному делению. Данные для России приведены в таблице ниже:



\noindent
\begin{tabular}[t]{|l|l|l|}
  \hline
    Уровень & Описание & Пример \\
  \hline
    1 & N/A & \\
  \hline
    2 & Государства & Российская Федерация \\
  \hline
    3 & Федеральные округа & Дальневосточный федеральный округ \\
  \hline
    4 & Субъекты Федерации & Хабаровский край \\
  \hline
    5 & Административные округа & Троицкий административный округ \\
      & городов федерального значения & (Москва) \\
  \hline
    6 & Муниципальные районы & г. Хабаровск, \\
      & субъектов федерации & Амурский район \\
  \hline
    7 & N/A (для России) & \\
  \hline
    8 & Внутригородские & \\
      & муниципальные территории & Район Измайлово (Москва) \\
      & городов федерального значения & \\
  \hline
    9 & Административные районы & Индустриальный район (Хабаровск) \\
      & городских округов и поселений & \\
  \hline
    10 & Микрорайоны городов\tablefootnote{Обсуждается. Подробную информацию можно узнать по ссылке: \url{http://wiki.openstreetmap.org/wiki/Tag:boundary\%3Dadministrative}.} & \\
  \hline
\end{tabular}

\end{table}
\vfill


\newpage
\section{Приложение 2}

\vspace{6pt}
{\large{\bf{Полезные ресурсы}}}

\vspace{6pt}
\noindent
В данной секции я собрал ссылки на ресурсы и проекты, относящиеся к визуализации данных на картах, которые не понадобились мне при подготовке данной работы, но могут быть полезны и интересны в качестве дополнительного материала.

  \begin{itemize}

    \item OSM Boundaries 4.0
          
          В данном проекте представлена большая часть (если не все) регионов мира по их административному уровню. Если возникает            неуверенность, какой уровень соответствует тому или иному региону, то я советую им воспользоваться.
          
          Ссылка: \url{https://osm.wno-edv-service.de/boundaries/}
          
    \item Конвертация пользовательской карты Яндекс в shape-файл
          
          По указанной ссылке Вы найдёте инструкцию по конвертации карты Яндекс, содержащей точечные данные в ESRI shapefile.
          
          Ссылка: \url{http://gis-lab.info/qa/yandex-shape.html}

  \end{itemize}
  
\newpage
\begin{thebibliography}{0}
  \bibitem{introtovis}
          Robin~Lovelace, James Cheshire, Rachel Oldroyd and others <<Introduction to visualizing spatial data in R>>
          \url{http://eprints.ncrm.ac.uk/3295/} (на момент 13.06.2016)
  \bibitem{gislab}
          GIS-Lab (<<ГИС Лаборатория>>)
          \url{http://gis-lab.info}
  \bibitem{OSMdownload}
          <<Поиск и загрузка данных OpenStreetMap>>
          \url{http://www.qgistutorials.com/ru/docs/downloading_osm_data.html}
  \bibitem{mastsit}
          Мастицкий С.Э., Шитиков В.К. (2014) Статистический анализ и визуализация данных с помощью R. – Электронная книга, адрес           доступа: 
          \url{http://r-analytics.blogspot.com}
  \bibitem{ggmap}
          D. Kahle and H. Wickham. ggmap: Spatial Visualization with ggplot2. The R Journal, 5(1), 144-161. URL
          \url{http://journal.r-project.org/archive/2013-1/kahle-wickham.pdf}
  \bibitem{SPAN}
          Roger S. Bivand, Edzer J. Pebesma, Virgilio Gomez-Rubio. <<Applied Spatial Data Analysis with R>>
          
\end{thebibliography}



\end{document}